

--- File: index_v1.js ---

#!/usr/bin/env node
import { Command } from "commander";
import inquirer from "inquirer";
import { execSync } from "child_process";
import simpleGit from "simple-git";
import fs from "fs-extra";
import chalk from "chalk";
import { createSpinner } from "nanospinner";
import os from "os";
import path from "path";
import Table from "cli-table3";
import net from "net";
import { v4 as uuidv4 } from "uuid";
import { formatDistanceToNow } from "date-fns";
import latestVersion from "latest-version";
import semver from "semver";
import { fileURLToPath } from "url";
import axios from "axios";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const program = new Command();

const packagePath = path.resolve(__dirname, "package.json");
const packageJson = JSON.parse(fs.readFileSync(packagePath, "utf-8"));

function updateCLI() {
  try {
    execSync("sudo npm install -g quicky", { stdio: "inherit" });
    console.log(chalk.green("Quicky has been upgraded to the latest version."));
  } catch (error) {
    console.error(chalk.red(`Failed to upgrade Quicky: ${error.message}`));
  }
}

async function checkForUpdates() {
  try {
    const latest = await latestVersion("quicky");
    if (semver.gt(latest, packageJson.version)) {
      console.log(
        `\n🚀 A new version of Quicky (v${chalk.bold.blue(
          latest
        )}) is available!`
      );

      const { shouldUpgrade } = await inquirer.prompt([
        {
          type: "confirm",
          name: "shouldUpgrade",
          message:
            "Would you like to update quicky to the latest version? Your configurations will be preserved.",
          default: true,
        },
      ]);

      if (shouldUpgrade) {
        updateCLI();
      } else {
        console.log(
          chalk.yellow("You can upgrade later by running 'quicky upgrade'.")
        );
      }
    }
  } catch (error) {
    console.error("Error checking for updates:", error);
  }
}

// Check for updates after the command execution
program.hook("postAction", async () => {
  const excludedCommands = ["upgrade", "uninstall"];
  const command = process.argv[2];

  if (!excludedCommands.includes(command)) {
    await checkForUpdates();
  }
});

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
const log = console.log;
const homeDir = os.homedir();
const defaultFolder = path.join(homeDir, ".quicky");
const projectsDir = defaultFolder + "/projects";
const tempDir = defaultFolder + "/temp";
const configPath = defaultFolder + "/config.json";

// Ensure directories exist
if (!fs.existsSync(projectsDir)) {
  fs.mkdirSync(projectsDir, { recursive: true });
}

if (!fs.existsSync(configPath)) {
  fs.writeFileSync(configPath, JSON.stringify({ projects: [] }, null, 2));
}

// Read configuration file once
const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));

const saveConfig = (config) => {
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
};

const updateProjectsConfig = ({
  pid = uuidv4().slice(0, 5),
  owner,
  repo,
  port,
  webhookId,
}) => {
  const project = {
    pid,
    owner,
    repo,
    port,
    webhookId,
    last_updated: new Date().toISOString(),
  };
  const existing = config.projects.find((p) => p.repo === repo);

  if (existing) {
    existing.port = port;
    existing.owner = owner;
  } else {
    config.projects.push(project);
  }

  saveConfig(config);
};

async function setupDomain(domain, port) {
  // Check if domain is pointing to the server's IP address using dig
  const checkDomainPointing = async (domain) => {
    let digResult = "";
    const spinner = createSpinner(
      `Checking if ${domain} points to this server...`
    ).start();
    while (!digResult) {
      digResult = execSync(`dig +short ${domain}`).toString().trim();
      if (!digResult) {
        spinner.update({
          text: `Waiting for ${domain} to point to this server...`,
        });
        await sleep(30000); // Wait for 30 seconds before checking again
      }
    }
    spinner.success({ text: `${domain} is now pointing to this server.` });
  };

  await checkDomainPointing(domain);

  const nginxConfigPath = `/etc/nginx/sites-available/${domain}`;
  const nginxSymlinkPath = `/etc/nginx/sites-enabled/${domain}`;

  // Check if the domain already exists in Nginx configuration
  if (fs.existsSync(nginxConfigPath) || fs.existsSync(nginxSymlinkPath)) {
    // Check if the domain exists in the config.json
    const domainExistsInConfig = (config.domains || []).some(
      (d) => d.domain === domain
    );
    if (!domainExistsInConfig) {
      log(
        chalk.yellow(
          `Warning: Domain ${domain} configuration files exist but domain is not in config.json.`
        )
      );
      log(`Overriding the existing configuration files for ${domain}.`);
    } else {
      log(chalk.red(`Error: Domain ${domain} already exists.`));
      log(
        `Please remove the existing configuration first or choose a different domain.`
      );
      log(
        `You can use the ${chalk.green(
          "quicky domains"
        )} command to manage domains.`
      );
      return;
    }
  }

  let zoneName = `zone_${uuidv4().slice(0, 5)}`;
  let nginxConfig = `
    limit_req_zone $binary_remote_addr zone=${zoneName}:10m rate=10r/s;

    server {
    listen 80;
    server_name ${domain};

    # Main location block for proxying to the Next.js application
    location / {
      # Enable rate limiting to prevent abuse
      limit_req zone=${zoneName} burst=5 nodelay;

      # Proxy settings for Next.js application
      proxy_pass http://localhost:${port};
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection 'upgrade';
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_set_header X-NginX-Proxy true;

      # Optimize buffering and memory limits for large requests
      proxy_busy_buffers_size 512k;
      proxy_buffers 4 512k;
      proxy_buffer_size 256k;

      # Disable buffering for real-time applications (like Next.js with WebSocket)
      proxy_buffering off;
      proxy_set_header X-Accel-Buffering no;

      # Caching control headers (prevents caching for dynamic content)
      add_header Cache-Control no-store;

      # Timeouts and keepalive settings to prevent disruptions
      proxy_connect_timeout 60s;
      proxy_send_timeout 60s;
      proxy_read_timeout 60s;
      keepalive_timeout 60s;

      # Handle large request bodies if needed
      client_max_body_size 50M;
    }

    # Logs for debugging and monitoring
    access_log /var/log/nginx/${domain}-access.log;
    error_log /var/log/nginx/${domain}-error.log;
    }

    # Additional security headers for best practices
    add_header X-Content-Type-Options "nosniff";
    add_header X-Frame-Options "DENY";
    add_header X-XSS-Protection "1; mode=block";
    add_header Referrer-Policy "no-referrer-when-downgrade";
    add_header Content-Security-Policy "default-src 'self'; img-src *; media-src * data:; style-src 'self' 'unsafe-inline'; font-src 'self' data:";
    `;

  // Write Nginx config to the sites-available  and sites-enabled directories
  const tempFilePath = `/tmp/${domain}.conf`;
  fs.writeFileSync(tempFilePath, nginxConfig, { mode: 0o644 });

  execSync(`sudo mv ${tempFilePath} ${nginxConfigPath}`, {
    stdio: "inherit",
  });

  // Check if the symlink already exists
  if (!fs.existsSync(nginxSymlinkPath)) {
    // Create a symlink to the sites-enabled directory
    execSync(`sudo ln -s ${nginxConfigPath} ${nginxSymlinkPath}`, {
      stdio: "inherit",
    });
  } else {
    log(chalk.yellow(`Symlink already exists for ${domain}.`));
  }

  // Restart Nginx to apply the changes
  execSync(`sudo service nginx restart`, { stdio: "inherit" });

  log(chalk.green(`Nginx configuration created for ${domain}.`));

  if (!config.email) {
    const { email } = await inquirer.prompt([
      {
        type: "input",
        name: "email",
        message: "Enter your email address for SSL certificate:",
        validate: (input) => {
          const emailRegex = /\S+@\S+\.\S+/;
          return emailRegex.test(input) ? true : "Please enter a valid email.";
        },
      },
    ]);

    config.email = email;
    saveConfig(config);
  }

  // Obtain SSL certificate using Certbot
  try {
    execSync("which certbot", { stdio: "ignore" });
    execSync("which python3-certbot-nginx", { stdio: "ignore" });
  } catch (error) {
    execSync("sudo apt install certbot python3-certbot-nginx -y", {
      stdio: "inherit",
    });
  } finally {
    try {
      execSync(
        `sudo certbot --nginx -d ${domain} --non-interactive --agree-tos --email ${config.email}`,
        { stdio: "inherit" }
      );
    } catch (error) {
      console.error(
        chalk.red(`Failed to obtain SSL certificate: ${error.message}`)
      );
      process.exit(1);
    }
  }

  log(chalk.green(`SSL certificate obtained and configured for ${domain}.`));
}

async function setupWebhookServer() {
  const { webhookUrl } = await inquirer.prompt([
    {
      type: "input",
      name: "webhookUrl",
      message:
        "Enter the URL where the webhook will be received (e.g., quicky.example.com):",
      validate: (input) => {
        if (input.trim() === "") {
          return "URL is required.";
        }
        if (
          config.domains &&
          config.domains.some((d) => d.domain === input.trim())
        ) {
          return "This domain is already in use. Please enter a different URL.";
        }
        return true;
      },
    },
  ]);

  const isPortInUse = (port) => {
    return new Promise((resolve) => {
      const server = net.createServer();

      server.once("error", (err) => {
        if (err.code === "EADDRINUSE") {
          resolve(true);
        } else {
          resolve(false);
        }
      });

      server.once("listening", () => {
        server.close();
        resolve(false);
      });

      server.listen(port);
    });
  };

  const getRandomPort = () => {
    return Math.floor(Math.random() * (65535 - 1024 + 1)) + 1024;
  };

  const getAvailablePort = async () => {
    let port;
    do {
      port = getRandomPort();
    } while (await isPortInUse(port));
    return port;
  };

  const availablePort = await getAvailablePort();

  // Set up the webhook server
  const git = simpleGit();
  const webhookPath = `${defaultFolder}/webhook`; // .quicky/webhook

  // Check if the webhook directory already exists and is not empty
  if (fs.existsSync(webhookPath) && fs.readdirSync(webhookPath).length > 0) {
    log(
      chalk.yellow(
        `Directory ${webhookPath} already exists and is not empty. Deleting...`
      )
    );

    // Stop and delete the PM2 instance if it exists
    try {
      execSync(
        `pm2 stop quicky-webhook-server && pm2 del quicky-webhook-server`,
        {
          stdio: "inherit",
        }
      );
    } catch (error) {
      log(chalk.red(`Failed to stop/delete PM2 instance: ${error.message}`));
    }

    fs.removeSync(webhookPath);
  }

  // Clone the webhook repository
  await git.clone(`https://github.com/alohe/quicky-webhook.git`, webhookPath);

  // Install dependencies
  execSync(`cd ${webhookPath} && npm install`, { stdio: "inherit" });

  // Set up the domain using the setupDomain function
  await setupDomain(webhookUrl, availablePort);

  // Generate a random secret for securing the webhook
  const webhookSecret = uuidv4();

  // Add a .env file to the webhook server
  const envFilePath = `${webhookPath}/.env`;

  fs.writeFileSync(
    envFilePath,
    `WEBHOOK_URL=${webhookUrl}\nWEBHOOK_PORT=${availablePort}\nWEBHOOK_SECRET=${webhookSecret}`,
    { flag: "wx" }
  );

  // Update the webhook URL and secret for all the projects managed by Quicky
  if (config.projects && config.projects.length > 0) {
    for (const project of config.projects) {
      if (project.webhookId) {
        const webhookConfig = {
          config: {
            url: `https://${webhookUrl}/webhook`,
            content_type: "json",
            secret: webhookSecret,
          },
        };

        try {
          await axios.patch(
            `https://api.github.com/repos/${project.owner}/${project.repo}/hooks/${project.webhookId}`,
            webhookConfig,
            {
              headers: {
                Authorization: `Bearer ${config.github.access_token}`,
              },
            }
          );
          console.log(`Webhook updated for project: ${project.repo}`);
        } catch (error) {
          console.error(
            `Error updating webhook for project ${project.repo}: ${error.message}`
          );
        }
      }
    }
  }

  try {
    // Start the webhook server with PM2
    execSync(
      `pm2 start ${path.join(
        webhookPath,
        "index.js"
      )} --name "quicky-webhook-server"`,
      {
        stdio: "inherit",
      }
    );
  } catch (error) {
    if (error.message.includes("Script already launched")) {
      // If the script is already running, attempt to restart it
      try {
        execSync(`pm2 restart "quicky-webhook-server"`, {
          stdio: "inherit",
        });
      } catch (restartError) {
        console.error(
          "Failed to restart the webhook server:",
          restartError.message
        );
        throw restartError; // Re-throw the error after logging
      }
    } else {
      console.error("Failed to start the webhook server:", error.message);
      throw error; // Re-throw the error after logging
    }
  }

  // Update the global config.json with the webhook server details
  config.webhook = {
    webhookUrl: `https://${webhookUrl}/webhook`,
    webhookPort: availablePort,
    secret: webhookSecret,
    pm2Name: "quicky-webhook-server",
  };
  saveConfig(config);

  log(
    chalk.green(
      `Webhook server set up and running at https://${webhookUrl}/webhook`
    )
  );
}

// Function to set up a webhook on a repository to be used during deployment
async function setupWebhook(repo) {
  // check if the webhook config is already set up in the config file
  if (
    !config.webhook ||
    !config.webhook.webhookUrl ||
    !config.webhook.webhookPort ||
    !config.webhook.secret
  ) {
    log(
      chalk.yellow(
        "Webhook server is not fully configured. Please set up the webhook server first."
      )
    );

    const { confirmWebhookSetup } = await inquirer.prompt([
      {
        type: "confirm",
        name: "setupWebhookServer",
        message: "Do you want to set up the webhook server now?",
        default: true,
      },
    ]);

    if (confirmWebhookSetup) {
      await setupWebhookServer();
    } else {
      log(chalk.yellow("Operation cancelled."));
      return;
    }
  }

  const webhookConfig = {
    name: "web",
    active: true,
    events: ["push"], // Listen for push events
    config: {
      url: config.webhook.webhookUrl, // User’s local service URL
      content_type: "json",
      secret: config.webhook.secret, // Add the secret for securing the webhook
    },
  };

  // Create the webhook on the user's repository
  try {
    const response = await axios.post(
      `https://api.github.com/repos/${repo}/hooks`,
      webhookConfig,
      {
        headers: {
          Authorization: `Bearer ${config.github.access_token}`,
        },
      }
    );
    console.log(`Webhook created: ${response.data.id}`);
    return response.data.id; // Return the webhook ID
  } catch (error) {
    console.error(`Error creating webhook: ${error.message}`);
    return null; // Return null if there was an error
  }
}

// Function to remove a webhook from a repo to be used during project deletion
async function removeWebhook(repo, webhookId) {
  try {
    await axios.delete(
      `https://api.github.com/repos/${repo}/hooks/${webhookId}`,
      {
        headers: {
          Authorization: `Bearer ${config.github.access_token}`,
        },
      }
    );
    console.log(`Webhook ${webhookId} removed.`);
    return true;
  } catch (error) {
    console.error(`Error removing webhook: ${error.message}`);
    return false;
  }
}

// Funtion to update a project with the latest changes from the repository
async function updateProject(project, promptEnv = false) {
  try {
    const git = simpleGit();
    const repoPath = `${projectsDir}/${project.repo}`;
    const tempPath = `${tempDir}/${project.repo}`;

    const spinner = createSpinner("Updating the project...").start();
    await sleep(1000);

    try {
      // Clone into temporary directory
      spinner.update({ text: "Cloning the repository..." });
      // Ensure the tempPath directory exists
      fs.ensureDirSync(tempPath);

      await git.clone(
        `https://${config.github.access_token}@github.com/${project.owner}/${project.repo}.git`,
        tempPath
      );

      spinner.update({ text: "Copying files to project directory..." });
      execSync(`cp -r ${tempPath}/* ${repoPath}`, {
        stdio: "inherit",
      });

      await sleep(1000);
      spinner.update({ text: "Cleaning up temporary files..." });
      execSync(`rm -rf ${tempPath}`);
      spinner.success({ text: "Repository updated successfully." });
      await sleep(1000);

      if (promptEnv) {
        // update .env file if it exists
        const envFilePath = `${repoPath}/.env`;
        if (fs.existsSync(envFilePath)) {
          const { updateEnv } = await inquirer.prompt([
            {
              type: "confirm",
              name: "updateEnv",
              message: `Do you want to update the .env file for ${project.repo}?`,
              default: false,
            },
          ]);

          if (updateEnv) {
            execSync(`nano ${envFilePath}`, { stdio: "inherit" });
          }
        } else {
          // prompt if user wants to add a .env file
          const { addEnv } = await inquirer.prompt([
            {
              type: "confirm",
              name: "addEnv",
              message: `Do you want to add a .env file for ${project.repo}?`,
              default: false,
            },
          ]);

          if (addEnv) {
            fs.writeFileSync(
              envFilePath,
              "# Add your environment variables below\n",
              { flag: "wx" }
            );
            execSync(`nano ${envFilePath}`, { stdio: "inherit" });
          }
        }
      }

      // Install dependencies, build the project, and restart the PM2 instance
      const packageManager = config.packageManager || "npm";
      const installCommand =
        packageManager === "bun" ? "bun install" : "npm install";
      execSync(`cd ${repoPath} && ${installCommand}`, {
        stdio: "inherit",
      });

      await sleep(1000);
      spinner.update({ text: " Building the project...\n" });
      const buildCommand =
        packageManager === "bun" ? "bun run build" : "npm run build";
      execSync(`cd ${repoPath} && ${buildCommand}`, {
        stdio: "inherit",
      });

      await sleep(1000);
      spinner.update({ text: " Restarting the project..." });

      // Check if the PM2 instance exists
      try {
        execSync(`cd ${repoPath} && pm2 describe ${project.repo}`, {
          stdio: "ignore",
        });
        // If it exists, restart
        execSync(`cd ${repoPath} && pm2 restart ${project.repo}`, {
          stdio: "inherit",
        });
      } catch (error) {
        // If it doesn't exist, start it on its port
        execSync(
          `cd ${repoPath} && pm2 start npm --name "${project.repo}" -- start -- --port ${project.port}`,
          {
            stdio: "inherit",
          }
        );
      }

      // Update the last_updated timestamp
      project.last_updated = new Date().toISOString();

      saveConfig(config);

      spinner.success({
        text: ` Project ${chalk.green.bold(
          project.repo
        )} updated successfully.`,
      });
    } catch (error) {
      spinner.error({
        text: `Failed to update project: ${error.message}`,
      });
    }

    process.exit(0);
  } catch (error) {
    console.error(chalk.red(`Error: ${error.message}`));
  }
}

function help() {
  const rabbit = `
 (\\(\\ 
 ( -.-)
 o_(")(")
`;

  log(chalk.blue(rabbit)); // Change color to whatever fits your style
  log(
    `${chalk.hex("#fd6d4c").bold("Quicky")}${chalk.hex("#f39549")(
      " - A CLI tool to deploy Next.js projects"
    )}`
  );
  log("");
  log("Usage:");
  // use the chalk package to colorize the output
  log(
    `${chalk.blue("  quicky")} ${chalk.hex("#FFA500")(
      "<command>"
    )} ${chalk.green("[options]")}`
  );
  log("");
  log("Commands:");
  log(
    `  ${chalk
      .hex("#cea9fe")
      .bold(
        "init"
      )}      Save your GitHub account details and install dependencies\n`
  );
  log(`  ${chalk.blue.bold("deploy")}    Deploy a Next.js project from GitHub`);
  log(
    `  ${chalk.blue.bold(
      "list"
    )}      List the current configuration and associated PM2 instances`
  );
  log(
    `  ${chalk.blue.bold(
      "manage"
    )}    Start, stop, restart, update, or delete a project \n`
  );
  log(
    `  ${chalk.blue.bold(
      "update"
    )}    Update a project by its PID, primarily used by the webhook server\n`
  );
  log(
    `  ${chalk.cyanBright.bold(
      "domains"
    )}   Manage domains and subdomains for the projects`
  );
  log(
    `  ${chalk.cyanBright.bold(
      "webhooks"
    )}  Manage the webhook server for your projects`
  );
  log("");
  log(`  ${chalk.hex("#fe64fa").bold("install")}   Install quicky globally`);
  log(
    `  ${chalk
      .hex("#fe64fa")
      .bold("upgrade")}   Upgrade quicky to the latest version`
  );
  log(
    `  ${chalk
      .hex("#fe64fa")
      .bold("uninstall")} Uninstall the CLI tool globally`
  );
  log("");
  log("Options:");
  log("  --help    Display help for the command");
  log("  -v, --version    Output the current version of Quicky");
  log("");
  log("For more information, visit https://quicky.dev");
}

program
  .version(
    `${packageJson.version}`,
    "-v, --version",
    "Output the current version of Quicky"
  )
  .action(async () => {
    help();
  });

program.option("-h, --help", "Display help for the command").action(() => {
  help();
});

program
  .command("install")
  .description("Install the CLI tool globally")
  .action(() => {
    try {
      execSync("sudo npm install -g quicky", { stdio: "inherit" });
      log(chalk.green("Quicky has been installed globally."));
    } catch (error) {
      console.error(chalk.red(`Failed to install Quicky: ${error.message}`));
    }
  });

program
  .command("uninstall")
  .description("Uninstall the CLI tool globally")
  .action(async () => {
    try {
      log(chalk.red.bold("\n⚠️  WARNING: This action is irreversible!"));
      log(
        chalk.red.bold(
          "All projects and configurations will be permanently deleted."
        )
      );
      const { confirmUninstall } = await inquirer.prompt([
        {
          type: "confirm",
          name: "confirmUninstall",
          message: `Are you sure you want to uninstall Quicky?`,
          default: false,
        },
      ]);

      if (confirmUninstall) {
        // Stop and delete all PM2 instances managed by Quicky
        try {
          const projectNames = config.projects.map((project) => project.repo);
          projectNames.forEach((name) => {
            execSync(`pm2 del ${name}`, {
              stdio: "inherit",
            });
          });

          // Stop and delete the webhook server if it exists
          if (config.webhook && config.webhook.pm2Name) {
            execSync(`pm2 del ${config.webhook.pm2Name}`, {
              stdio: "inherit",
            });
          }

          log(
            chalk.green(
              "All PM2 instances managed by Quicky have been stopped and deleted."
            )
          );
        } catch (error) {
          log(chalk.red(`Failed to stop PM2 instances: ${error.message}`));
        }

        // Delete Nginx configurations managed by Quicky
        try {
          const domains = config.domains || [];
          domains.forEach((domain) => {
            const domainConfigPath = `/etc/nginx/sites-available/${domain.domain}`;
            const domainSymlinkPath = `/etc/nginx/sites-enabled/${domain.domain}`;
            if (fs.existsSync(domainConfigPath)) {
              execSync(`sudo rm ${domainConfigPath}`, { stdio: "inherit" });
            }
            if (fs.existsSync(domainSymlinkPath)) {
              execSync(`sudo rm ${domainSymlinkPath}`, { stdio: "inherit" });
            }
          });
          log(
            chalk.green(
              "Nginx configurations for all domains managed by Quicky have been deleted."
            )
          );
        } catch (error) {
          log(
            chalk.red(`Failed to delete Nginx configurations: ${error.message}`)
          );
        }

        // Delete the default folder where projects and configurations are stored
        try {
          fs.removeSync(defaultFolder);
          log(chalk.green("Quicky has been uninstalled successfully."));
        } catch (error) {
          log(chalk.red(`Failed to delete Quicky folder: ${error.message}`));
        }

        // Uninstall the CLI tool
        try {
          execSync("sudo npm uninstall -g quicky", { stdio: "inherit" });
          log(chalk.green("✔ Quicky has been uninstalled successfully."));
        } catch (error) {
          log(chalk.red(`Failed to uninstall Quicky: ${error.message}`));
        }
      } else {
        log(chalk.yellow("Uninstallation of projects cancelled."));
      }
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
    }
  });

program
  .command("init")
  .description("Save your GitHub account details and install dependencies")
  .option("--username <username>", "GitHub username")
  .option("--token <token>", "GitHub personal access token")
  .option(
    "--packageManager <packageManager>",
    "Package manager to use (npm|bun)"
  )
  .action(async (cmd) => {
    try {
      let { username, token, packageManager } = cmd || config.github || {};
      if (!username || !token || !packageManager) {
        const answers = await inquirer.prompt([
          {
            name: "username",
            message: "Enter your GitHub username:",
            default: username,
          },
          {
            name: "token",
            message: "Enter your GitHub personal access token:",
            default: token,
          },
          {
            type: "list",
            name: "packageManager",
            message: "Choose your package manager:",
            choices: ["npm", "bun"],
            default: packageManager,
          },
        ]);

        username = answers.username;
        token = answers.token;
        packageManager = answers.packageManager;
      }

      if (username && token) {
        config.github = { username, access_token: token };
        config.packageManager = packageManager;
        saveConfig(config);

        // Check if the webhook server is already running
        if (config.webhook && config.webhook.pm2Name) {
          try {
            const pm2Status = execSync(
              `pm2 describe ${config.webhook.pm2Name}`,
              {
                stdio: "pipe",
              }
            ).toString();

            if (!pm2Status.includes("online")) {
              log(chalk.yellow("Webhook server is not running. Restarting..."));
              execSync(`pm2 restart ${config.webhook.pm2Name}`, {
                stdio: "inherit",
              });
              log(chalk.green("Webhook server restarted successfully."));
            } else {
              log(chalk.green("Webhook server is already running."));
            }
          } catch (error) {
            log(
              chalk.red(
                `Failed to check or restart webhook server: ${error.message}`
              )
            );
            log(chalk.yellow("Attempting to start webhook server..."));
            await setupWebhookServer();
          }
        } else {
          log("Webhook server is not configured. Setting up...");
          await setupWebhookServer();
        }

        // Check if PM2 is already installed, if not, install it using npm
        const spinner = createSpinner(
          "Saving your GitHub account details and installing dependencies..."
        ).start();
        await sleep(1000);
        try {
          execSync("pm2 -v", { stdio: "ignore" });
          spinner.success({
            text: "GitHub account details saved and dependencies installed successfully!",
          });
        } catch (error) {
          try {
            execSync("npm install -g pm2", { stdio: "inherit" });
            spinner.success({
              text: "GitHub account details saved and dependencies installed successfully!",
            });
          } catch (installError) {
            spinner.error({
              text: `Failed to install dependencies. Please ensure you have npm installed.`,
            });
          }
        }

        log(
          `\n📁 Configuration files are stored at: ${chalk.green(configPath)}`
        );
        log(`📂 Projects will be stored in: ${chalk.green(projectsDir)}`);
        log(
          `\n🚀 You can now deploy your Next.js projects using ${chalk.green(
            "quicky deploy"
          )}`
        );

        // Ask user if they want to deploy a project now
        const { deployNow } = await inquirer.prompt([
          {
            type: "confirm",
            name: "deployNow",
            message: "Do you want to deploy a project now?",
            default: false,
          },
        ]);

        if (deployNow) {
          execSync(`quicky deploy`, { stdio: "inherit" });
        } else {
          process.exit(0);
        }
      } else {
        spinner.error({
          text: `Failed to save GitHub account details. Please ensure you have a valid personal access token. ${chalk.green(
            "https://github.com/settings/tokens"
          )}`,
        });
      }
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
    }
  });

// Configure webhooks
program
  .command("webhooks")
  .description("Manage the webhook server for your projects")
  .action(async () => {
    const webhookPath = `${defaultFolder}/webhook`;

    const isWebhookServerRunning = () => {
      try {
        const pm2Status = execSync(`pm2 describe ${config.webhook.pm2Name}`, {
          stdio: "pipe",
        }).toString();
        return pm2Status.includes("online");
      } catch (error) {
        return false;
      }
    };

    if (isWebhookServerRunning()) {
      const { action } = await inquirer.prompt([
        {
          type: "list",
          name: "action",
          message: "Webhook server is running. What would you like to do?",
          choices: ["Restart", "Check Status", "Stop", "Show Logs"],
        },
      ]);

      if (action === "Restart") {
        try {
          // Check if node_modules exists, if not run npm install
          if (!fs.existsSync(`${webhookPath}/node_modules`)) {
            log(chalk.yellow("node_modules not found. Running npm install..."));
            execSync(`cd ${webhookPath} && npm install`, { stdio: "inherit" });
          }

          execSync(`pm2 restart ${config.webhook.pm2Name}`, {
            stdio: "inherit",
          });
          log(chalk.green("Webhook server restarted successfully."));
        } catch (error) {
          log(chalk.red(`Failed to restart webhook server: ${error.message}`));
        }
      } else if (action === "Check Status") {
        try {
          const pm2Status = execSync(
            `pm2 describe ${config.webhook.pm2Name}`,
            {
              stdio: "pipe",
            }
          ).toString();

          if (pm2Status.includes("online")) {
            log(chalk.green("Webhook server is running."));
          } else {
            log(chalk.red("Webhook server is not running."));
          }
        } catch (error) {
          log(
            chalk.red(`Failed to check webhook server status: ${error.message}`)
          );
        }
      } else if (action === "Stop") {
        try {
          execSync(`pm2 stop ${config.webhook.pm2Name}`, {
            stdio: "inherit",
          });
          log(chalk.green("Webhook server stopped successfully."));
        } catch (error) {
          log(chalk.red(`Failed to stop webhook server: ${error.message}`));
        }
      } else if (action === "Show Logs") {
        try {
          const { logType } = await inquirer.prompt([
            {
              type: "list",
              name: "logType",
              message: "Which logs would you like to see?",
              choices: ["Output Logs", "Error Logs"],
            },
          ]);

          const logCommand =
            logType === "Output Logs"
              ? `pm2 logs ${config.webhook.pm2Name} --lines 100`
              : `pm2 logs ${config.webhook.pm2Name} --err --lines 100`;

          execSync(logCommand, { stdio: "inherit" });
        } catch (error) {
          log(chalk.red(`Failed to show logs: ${error.message}`));
        }
      }
    } else {
      await setupWebhookServer();
    }
  });

// Deploy project
program
  .command("deploy")
  .description("Deploy a Next.js project from GitHub")
  .option("--owner <owner>", "GitHub repository owner")
  .option("--repo <repo>", "GitHub repository name")
  .option("--port <port>", "Port to deploy the application")
  .action(async (cmd) => {
    try {
      let { owner, repo, port } = cmd;
      // Read stored username from config
      let defaultOwner = owner;
      if (config.github && config.github.username) {
        defaultOwner = owner || config.github.username;
      }
      if (!repo || !port) {
        const answers = await inquirer.prompt([
          {
            type: "input",
            name: "owner",
            message: "Enter the GitHub repository owner/org name:",
            default: defaultOwner,
            when: () => !owner,
          },
          {
            type: "input",
            name: "repo",
            message: "Enter the GitHub repository name:",
            when: () => !repo,
          },
          {
            type: "input",
            name: "port",
            message: "Enter the port to deploy the application:",
            when: () => !port,
            validate: (input) => {
              const portNumber = parseInt(input, 10);
              if (isNaN(portNumber) || portNumber <= 0 || portNumber > 65535) {
                return "Please enter a valid port number between 1 and 65535.";
              }
              return true;
            },
          },
        ]);

        owner = owner || answers.owner;
        repo = repo || answers.repo;
        port = port || answers.port;
      }

      if (!owner || !repo || !port) {
        log(chalk.red("Error: Missing required arguments."));
        process.exit(1);
      }

      if (owner.length === 0 || repo.length === 0 || port.length === 0) {
        log(chalk.red("Error: Arguments cannot be empty."));
        process.exit(1);
      }

      const existingProject = config.projects.find((p) => p.repo === repo);

      if (existingProject) {
        log(
          chalk.yellowBright(
            `\nProject ${chalk.bold(
              repo
            )} already exists. \nUse the ${chalk.bold(
              "manage"
            )} command to manage the project or the ${chalk.bold(
              "list"
            )} command to view all your deployed projects.\n`
          )
        );
        process.exit(1);
      }

      const isPortInUse = (port) => {
        return new Promise((resolve) => {
          const server = net.createServer();

          server.once("error", (err) => {
            if (err.code === "EADDRINUSE") {
              resolve(true);
            } else {
              resolve(false);
            }
          });

          server.once("listening", () => {
            server.close();
            resolve(false);
          });

          server.listen(port);
        });
      };

      const getAvailablePort = async (port) => {
        while (await isPortInUse(port)) {
          const answer = await inquirer.prompt([
            {
              type: "input",
              name: "port",
              message: `Port ${port} is already in use. Please enter another port:`,
              validate: (input) => {
                const portNumber = parseInt(input, 10);
                return Number.isInteger(portNumber) &&
                  portNumber > 0 &&
                  portNumber <= 65535
                  ? true
                  : "Please enter a valid port number (1-65535).";
              },
            },
          ]);
          port = answer.port;
        }
        return port;
      };

      port = await getAvailablePort(port);

      const git = simpleGit();
      const repoPath = `${projectsDir}/${repo}`;

      // Check if the directory already exists and is not empty
      if (fs.existsSync(repoPath) && fs.readdirSync(repoPath).length > 0) {
        const existingProject = config.projects.find((p) => p.repo === repo);
        if (!existingProject) {
          log(
            `⚠️  Directory ${chalk
              .hex("#FFA500")
              .bold(repoPath)} exists and is not linked to any project.`
          );
          const { deleteFolder } = await inquirer.prompt([
            {
              type: "confirm",
              name: "deleteFolder",
              message: `Delete ${repoPath} and continue?`,
              default: false,
            },
          ]);

          if (deleteFolder) {
            fs.removeSync(repoPath);
          } else {
            log(chalk.yellow("Operation cancelled."));
            process.exit(1);
          }
        } else {
          log(
            `⚠️ Directory ${chalk
              .hex("#FFA500")
              .bold(repoPath)} exists and is not empty. Use ${chalk.green(
              "manage"
            )} to manage the project.`
          );
          process.exit(1);
        }
      }

      if (!config.github || !config.github.access_token) {
        log(
          chalk.red(
            "Error: GitHub access token not found. Please run the init command first."
          )
        );
        log(
          `You can run the ${chalk.green(
            "quicky init"
          )} command to save your GitHub account details.`
        );
        process.exit(1);
      }

      await git.clone(
        `https://${config.github.access_token}@github.com/${owner}/${repo}.git`,
        repoPath
      );

      let pid = uuidv4().slice(0, 5);

      pid =
        config.projects.filter((p) => p.pid === pid).length > 0
          ? uuidv4().slice(0, 5)
          : pid;

      // Prompt user to add a .env file or not
      const { addEnv } = await inquirer.prompt([
        {
          type: "confirm",
          name: "addEnv",
          message: "Do you want to add a .env file?",
          default: false,
        },
      ]);

      if (addEnv) {
        const envFilePath = `${projectsDir}/${repo}/.env`;
        fs.writeFileSync(
          envFilePath,
          "# Add your environment variables below\n",
          { flag: "wx" }
        );
        execSync(`nano ${envFilePath}`, { stdio: "inherit" });
      }

      log(
        chalk.green(
          `✔ Project ${chalk.bold(repo)} cloned successfully. Deploying...`
        )
      );

      const packageManager = config.packageManager || "npm";

      // If package manager is bun, install bun and run bun install
      if (packageManager === "bun") {
        try {
          execSync("bun -v", { stdio: "ignore" });
        } catch (error) {
          try {
            execSync("unzip -v", { stdio: "ignore" });
          } catch (error) {
            log(chalk.yellow("Unzip is not installed. Installing unzip..."));
            execSync("sudo apt-get install -y unzip", { stdio: "inherit" });
          } finally {
            await execSync("curl -fsSL https://bun.sh/install | bash", {
              stdio: "inherit",
            });

            execSync("source ~/.bashrc", { stdio: "inherit" });
          }
        }
      } else {
        try {
          execSync("npm -v", { stdio: "ignore" });
        } catch (error) {
          log(
            chalk.red(
              "Error: npm is not installed. Please install Node.js to use npm."
            )
          );
          process.exit(1);
        }
      }

      // Check if swap space is already enabled
      const checkSwap = () => {
        try {
          const swapInfo = execSync("swapon --show", { encoding: "utf-8" });
          return swapInfo.includes("/swapfile");
        } catch (error) {
          return false;
        }
      };

      // Create and enable swap space if not already enabled
      const createSwap = () => {
        try {
          log(chalk.yellow("Creating swap space..."));
          execSync("sudo fallocate -l 1G /swapfile", { stdio: "inherit" });
          execSync("sudo chmod 600 /swapfile", { stdio: "inherit" });
          execSync("sudo mkswap /swapfile", { stdio: "inherit" });
          execSync("sudo swapon /swapfile", { stdio: "inherit" });
          execSync(
            "echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab",
            { stdio: "inherit" }
          );
          log(chalk.green("✔ Swap space created and enabled successfully."));
        } catch (error) {
          console.error(
            chalk.red(`Failed to create swap space: ${error.message}`)
          );
          process.exit(1);
        }
      };

      if (!checkSwap()) {
        createSwap();
      }

      const installCommand =
        packageManager === "bun" ? "bun install" : "npm install";
      const buildCommand =
        packageManager === "bun" ? "bun run build" : "npm run build";
      const startCommand = `pm2 start npm --name "${repo}" -- start -- --port ${port}`;

      // Install dependencies and build the project
      try {
        execSync(`cd ${projectsDir}/${repo} && ${installCommand}`, {
          stdio: "inherit",
        });
      } catch (error) {
        console.error(
          chalk.red(`Failed to install dependencies: ${error.message}`)
        );
        process.exit(1);
      }

      try {
        execSync(`cd ${projectsDir}/${repo} && ${buildCommand}`, {
          stdio: "inherit",
        });
      } catch (error) {
        console.error(
          chalk.red(`Failed to build the project: ${error.message}`)
        );
        process.exit(1);
      }

      try {
        try {
          execSync("pm2 -v", { stdio: "ignore" });
        } catch (error) {
          execSync("npm install -g pm2", { stdio: "inherit" });
        }
      } catch (error) {
        console.error(
          chalk.red(
            "PM2 is not installed. Please install it using `npm install -g pm2`"
          )
        );
        process.exit(1);
      }

      execSync(`cd ${projectsDir}/${repo} && ${startCommand}`, {
        stdio: "inherit",
      });

      // Set up the webhook for the repository
      const webhookId = await setupWebhook(`${owner}/${repo}`);

      // Save the webhook ID to the project configuration
      updateProjectsConfig({ pid, owner, repo, port, webhookId });

      log(`Project deployed successfully on port ${port}`);
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
    }
  });

// list all projects and domains
const status = () => {
  const table = new Table({
    head: [
      chalk.cyan.bold("PID"),
      chalk.cyan.bold("Owner"),
      chalk.cyan.bold("Repository"),
      chalk.cyan.bold("Port"),
      chalk.cyan.bold("Status"),
      chalk.cyan.bold("Last Updated"),
    ],
    style: {
      head: ["cyan", "bold"],
    },
    wordWrap: true,
    colWidths: [10, 15, 15, 10, 15, 20],
  });

  config.projects.forEach((project) => {
    let pm2Status = "Not Running";
    try {
      const pm2List = execSync(`pm2 jlist`, { encoding: "utf-8" });
      const pm2Instances = JSON.parse(pm2List);
      const instance = pm2Instances.find((inst) => inst.name === project.repo);
      if (instance) {
        pm2Status = instance.pm2_env.status;
      }
    } catch (error) {
      pm2Status = "Error";
    }

    table.push([
      chalk.yellow.bold(project.pid),
      chalk.white(project.owner),
      chalk.white(project.repo),
      chalk.greenBright.bold(project.port),
      pm2Status === "online" ? chalk.green(pm2Status) : chalk.red(pm2Status),
      chalk.white(
        formatDistanceToNow(new Date(project.last_updated), {
          addSuffix: true,
        })
      ),
    ]);
  });

  log(table.toString());
};

program
  .command("list")
  .description(
    "List the current configuration, associated PM2 instances, and domains"
  )
  .action(() => {
    if (config.projects.length === 0) {
      log(chalk.yellow("No projects found."));
      return;
    }

    status();

    log(
      `\nTo manage your projects, use the ${chalk.blue(
        "quicky manage"
      )} command. You can ${chalk.blue("start")}, ${chalk.blue(
        "stop"
      )}, ${chalk.blue("restart")}, ${chalk.blue("update")}, or ${chalk.red(
        "delete"
      )} your projects.`
    );
    log(`For more details, visit ${chalk.green("https://quicky.dev")}\n`);
  });

// start / stop / restart projects (pm2 wrapper) also delete projects
program
  .command("manage")
  .description("start, stop, restart, update, or delete a project")
  .action(async () => {
    try {
      if (!config.projects.length) {
        log(chalk.red("No projects found to manage."));
        return;
      }

      // List all projects and their status
      status();

      const { selectedProject, action } = await inquirer.prompt([
        {
          type: "list",
          name: "selectedProject",
          message: "Select a project to manage:",
          choices: config.projects.map((project) => project.repo),
        },
        {
          type: "list",
          name: "action",
          message: "What action would you like to perform?",
          choices: ["start", "stop", "restart", "update", "delete"],
        },
      ]);

      const project = config.projects.find((p) => p.repo === selectedProject);

      if (!project) {
        log(chalk.red("Error: Selected project not found."));
        return;
      }

      if (action === "update") {
        // Update a running project with the latest changes from the GitHub repository
        updateProject(project, true);
      } else if (action === "delete") {
        try {
          if (!config.projects.length) {
            log(chalk.yellowBright("No projects found to delete."));
            return;
          }

          const { confirmDelete } = await inquirer.prompt([
            {
              type: "confirm",
              name: "confirmDelete",
              message: `Are you sure you want to delete the project ${chalk.redBright(
                selectedProject
              )}?`,
              default: false,
            },
          ]);

          if (confirmDelete) {
            const spinner = createSpinner("Deleting the project...").start();
            await sleep(1000);

            const project = config.projects.find(
              (p) => p.repo === selectedProject
            );
            if (project) {
              const repoPath = `${projectsDir}/${project.repo}`;

              // Stop and delete the project from PM2 if it exists
              try {
                execSync(`pm2 stop ${project.repo}`, { stdio: "ignore" });
                execSync(`pm2 del ${project.repo}`, { stdio: "ignore" });
              } catch (error) {
                log(
                  chalk.yellow(
                    `\nProject ${project.repo} is not running on PM2. Skipping...`
                  )
                );
              }

              // Remove the project directory
              execSync(`rm -rf ${repoPath}`);

              log(
                chalk.green(`\n✔ Project ${project.repo} deleted successfully.`)
              );

              // Remove the project from the configuration file
              config.projects = config.projects.filter(
                (p) => p.repo !== selectedProject
              );

              // Remove associated domains
              if (config.domains && config.domains.length > 0) {
                config.domains = config.domains.filter(
                  (domain) => domain.pid !== project.pid
                );
              }

              // Delete the nginx config file and restart nginx
              const nginxConfigFile = `/etc/nginx/sites-available/${selectedProject}`;
              const nginxSymlinkFile = `/etc/nginx/sites-enabled/${selectedProject}`;

              if (fs.existsSync(nginxConfigFile)) {
                execSync(`sudo rm -f ${nginxConfigFile}`, { stdio: "inherit" });
              }

              if (fs.existsSync(nginxSymlinkFile)) {
                execSync(`sudo rm -f ${nginxSymlinkFile}`, {
                  stdio: "inherit",
                });
              }

              execSync(`sudo service nginx restart`, { stdio: "inherit" });

              // Remove webhook if it exists
              if (project.webhookId) {
                await removeWebhook(
                  `${project.owner}/${project.repo}`,
                  project.webhookId
                );
              }

              saveConfig(config);
            }

            spinner.success({
              text: `Project ${selectedProject} deleted successfully.`,
            });

            process.exit(0);
          } else {
            log(chalk.yellow("Project deletion cancelled."));
            process.exit(0);
          }
        } catch (error) {
          console.error(chalk.red(`Error: ${error.message}`));
        }
      } else {
        const pm2Command = `pm2 ${action} ${project.repo}`;

        try {
          execSync(pm2Command, { stdio: "inherit" });
          log(chalk.green(`Project ${project.repo} ${action}ed successfully.`));
        } catch (error) {
          console.error(
            chalk.red(
              `Failed to ${action} project ${project.repo}: ${error.message}`
            )
          );
        }
      }
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
    }
  });

program
  .command("update <pid>")
  .description("Update a project by its PID")
  .action(async (pid) => {
    try {
      const project = config.projects.find((p) => p.pid === pid);
      if (!project) {
        console.error(chalk.red(`Project with PID ${pid} not found.`));
        process.exit(1);
      }

      await updateProject(project, false);

      process.exit(0);
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
      process.exit(1);
    }
  });

// Manage domains and subdomains for the projects
program
  .command("domains")
  .description("Manage domains and subdomains for the projects")
  .action(async () => {
    try {
      // Install Nginx and Certbot if not already installed
      try {
        execSync("nginx -v", { stdio: "ignore" });
      } catch (error) {
        execSync("sudo apt install nginx -y", { stdio: "inherit" });
      }

      try {
        // Check if certbot and the nginx plugin are installed
        execSync("certbot --version && certbot plugins | grep nginx", {
          stdio: "ignore",
        });
      } catch (error) {
        // If not installed, install certbot and the nginx plugin
        execSync("sudo apt install certbot python3-certbot-nginx -y", {
          stdio: "inherit",
        });
      }

      // Read project list to get a list of existing projects and their ports.
      const projects = config.projects;

      if (projects.length === 0) {
        log(chalk.yellow("No projects found. Please deploy a project first."));
        return;
      } else {
        // check if there are any domains already associated with the projects
        if (config.domains && config.domains.length > 0) {
          await handleListDomains(projects);
        }
      }

      const { action } = await inquirer.prompt([
        {
          type: "list",
          name: "action",
          message: "What would you like to do?",
          choices: ["Add Domain", "Remove Domain"],
        },
      ]);

      if (action === "Add Domain") {
        await handleAddDomain(projects);
      } else if (action === "Remove Domain") {
        await handleRemoveDomain(projects);
      }
    } catch (error) {
      console.error(chalk.red(`Error: ${error.message}`));
    }
  });

// Function to add a new domain or subdomain and configure Nginx and SSL
async function handleAddDomain(projects) {
  try {
    const { project, domain } = await inquirer.prompt([
      {
        type: "list",
        name: "project",
        message: "Select a project to associate the domain with:",
        choices: projects.map((p) => p.repo),
      },
      {
        type: "input",
        name: "domain",
        message: "Enter the domain or subdomain you want to add:",
        validate: (input) => {
          // Basic domain validation
          const domainRegex = /^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
          return domainRegex.test(input)
            ? true
            : "Please enter a valid domain.";
        },
      },
    ]);

    const selectedProject = projects.find((p) => p.repo === project);
    if (!selectedProject) {
      log(chalk.red("Error: Selected project not found."));
      return;
    }

    // a function for domain setup
    await setupDomain(domain, selectedProject.port);

    // Update the config file with the new domain
    const projectPid = selectedProject.pid;

    if (!config.domains) {
      config.domains = [];
    }

    if (config.domains.some((d) => d.domain === domain)) {
      log(chalk.red(`Domain ${domain} already exists.`));
      return;
    }

    config.domains.push({ pid: projectPid, domain });
    saveConfig(config);
    log(
      chalk.green(
        `Domain ${domain} added successfully to project ${selectedProject.repo}.`
      )
    );
    log(chalk.green(`You can now access your project at https://${domain}`));
    log(
      `Please make sure your domain is pointing to this server's IP address. It may take up to 48 hours for DNS changes to take effect.`
    );
  } catch (error) {
    console.error(chalk.red(`Failed to add domain: ${error.message}`));
  }
}

// Function to remove a domain or subdomain and delete Nginx and Certbot configuration files
async function handleRemoveDomain(projects) {
  try {
    const { project } = await inquirer.prompt([
      {
        type: "list",
        name: "project",
        message: "Select the project you want to remove a domain from:",
        choices: projects.map((p) => p.repo),
      },
    ]);

    const selectedProject = projects.find((p) => p.repo === project);
    if (!selectedProject) {
      log(chalk.red("Error: Selected project not found."));
      return;
    }

    const projectDomains = config.domains.filter(
      (d) => d.pid === selectedProject.pid
    );
    if (projectDomains.length === 0) {
      log(chalk.red("Error: Selected project has no associated domains."));
      return;
    }

    const { domain } = await inquirer.prompt([
      {
        type: "list",
        name: "domain",
        message: "Select the domain you want to remove:",
        choices: projectDomains.map((d) => d.domain),
      },
    ]);

    // Remove Nginx configuration
    const nginxConfigPath = `/etc/nginx/sites-available/${domain}`;
    if (fs.existsSync(nginxConfigPath)) {
      const command = `sudo rm -f ${nginxConfigPath} /etc/nginx/sites-enabled/${domain}`;
      execSync(command, { stdio: "inherit" });
      execSync(`sudo service nginx restart`, { stdio: "inherit" });
      log(chalk.green(`Nginx configuration removed for ${domain}.`));
    }

    // Remove SSL certificate using Certbot
    const certbotCommand = `sudo certbot delete --cert-name ${domain}`;
    execSync(certbotCommand, { stdio: "inherit" });
    log(chalk.green(`SSL certificate removed for ${domain}.`));

    // Update the config file and remove the domain from the config
    config.domains = config.domains.filter((d) => d.domain !== domain);
    saveConfig(config);
    log(
      chalk.green(
        `Domain ${domain} removed successfully from project ${project}.`
      )
    );
  } catch (error) {
    console.error(chalk.red(`Failed to remove domain: ${error.message}`));
  }
}

// Function to list all domains and their associated projects
async function handleListDomains(projects) {
  try {
    if (projects.length === 0) {
      log(chalk.yellow("No projects found."));
      return;
    }

    const table = new Table({
      head: [
        chalk.cyan.bold("Project"),
        chalk.cyan.bold("Domain"),
        chalk.cyan.bold("Port"),
      ],
      style: {
        head: ["cyan", "bold"],
        border: ["grey"],
      },
      colWidths: [20, 30, 10],
    });

    projects.forEach((project) => {
      const projectDomains = config.domains.filter(
        (d) => d.pid === project.pid
      );
      projectDomains.forEach((domain) => {
        table.push([
          chalk.white(project.repo),
          chalk.blue(domain.domain),
          chalk.white(project.port),
        ]);
      });
    });

    log(chalk.green.bold("\nDomains Configuration:"));
    log(table.toString());
  } catch (error) {
    console.error(chalk.red(`Failed to list domains: ${error.message}`));
  }
}

// Upgrade the CLI to the latest version
program
  .command("upgrade")
  .description("Upgrade the CLI to the latest version")
  .action(() => {
    try {
      // Get the currently installed version
      const currentVersion = execSync("npm list -g quicky --depth=0", {
        encoding: "utf-8",
      }).match(/quicky@([\d.]+)/)[1];

      // Get the latest version available in the npm registry
      const latestVersion = execSync("npm show quicky version", {
        encoding: "utf-8",
      }).trim();

      if (currentVersion === latestVersion) {
        console.log(
          chalk.yellow(
            `Quicky CLI is already at the latest version (${currentVersion}).`
          )
        );
        return;
      }

      // Proceed to upgrade
      console.log(chalk.blue("Upgrading Quicky CLI to the latest version..."));
      updateCLI();
    } catch (error) {
      console.error(chalk.red(`Failed to upgrade the CLI: ${error.message}`));
    }
  });

// Global error handling
process.on("unhandledRejection", (reason, promise) => {
  console.error(
    chalk.red(`Unhandled Rejection at: ${promise}, reason: ${reason}`)
  );
  process.exit(1);
});

process.on("uncaughtException", (error) => {
  console.error(chalk.red(`Uncaught Exception: ${error.message}`));
  process.exit(1);
});

program.parse(process.argv);



--- File: readme-build.md ---

# Build Guide for Quicky CLI

## Prerequisites

1. Node.js (v18 or newer)
2. npm (v8 or newer)
3. Git

## Initial Setup

1. Clone the repository:

```bash
git clone https://github.com/alohe/quicky.git
cd quicky
```

2. Install dependencies:

```bash
npm install
```

## Build Commands

### Standard Build

```bash
npm run build
```

This will:

1. Clean the dist directory
2. Transpile JavaScript using Babel
3. Copy necessary files

### Development Build (Watch Mode)

```bash
npm run dev
```

This watches for changes and rebuilds automatically.

### Clean Build Directory

```bash
npm run clean
```

### Lint and Format Code

```bash
# Run ESLint
npm run lint

# Format with Prettier
npm run format
```

## Cross-Platform Considerations

### File Paths

Always use `path.join()` for file paths:

```javascript
import path from "path";

const configPath = path.join(process.cwd(), "config.json");
```

### Line Endings

Add `.gitattributes`:

```
* text=auto eol=lf
*.js text eol=lf
*.json text eol=lf
*.md text eol=lf
```

### Environment Variables

Use cross-platform environment variable access:

```javascript
import os from "os";

const homeDir = os.homedir();
const tempDir = os.tmpdir();
```

### Executing Commands

Use cross-platform command execution:

```javascript
import { exec } from "child_process";
import { promisify } from "util";

const execAsync = promisify(exec);

// Instead of direct shell commands
const { stdout } = await execAsync("npm --version", { shell: true });
```

## Project Structure

```
quicky/
├── dist/             # Compiled files
├── src/              # Source files
│   ├── cli.js        # Entry point (with shebang)
│   ├── commands/     # CLI commands
│   ├── lib/          # Core libraries
│   ├── services/     # Services
│   └── utils/        # Utilities
├── __tests__/        # Tests
├── package.json
└── README.md
```

## Local Development Testing

1. Link the package locally:

```bash
npm link
```

2. Test the CLI:

```bash
quicky --version
```

3. Unlink when done:

```bash
npm unlink
```

## Build Process Details

### 1. Cleaning

Uses `rimraf` for cross-platform directory cleaning:

```javascript
import { rimraf } from "rimraf";
await rimraf("./dist");
```

### 2. Transpiling

Babel configuration for cross-platform compatibility:

```javascript
// babel.config.js
export default {
  presets: [
    [
      "@babel/preset-env",
      {
        targets: {
          node: "current"
        }
      }
    ]
  ]
};
```

### 3. File Operations

Use `fs-extra` for cross-platform file operations:

```javascript
import fs from "fs-extra";

// Copy files
await fs.copy(sourcePath, targetPath);

// Ensure directory exists
await fs.ensureDir(directoryPath);

// Write file
await fs.writeJSON(filePath, data, { spaces: 2 });
```

## Testing Across Platforms

Run tests on different platforms:

```json
{
  "scripts": {
    "test": "jest",
    "test:windows": "cross-env PLATFORM=win32 jest",
    "test:linux": "cross-env PLATFORM=linux jest",
    "test:mac": "cross-env PLATFORM=darwin jest"
  }
}
```

## CI/CD Pipeline

GitHub Actions workflow for multi-platform testing:

```yaml
name: Cross-Platform Build

on: [push, pull_request]

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        node-version: [18.x, 20.x]

    steps:
      - uses: actions/checkout@v2

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build
        run: npm run build
```

## Common Cross-Platform Issues

1. **Path Separators**

   ```javascript
   // Bad
   const configPath = process.cwd() + "/config.json";

   // Good
   const configPath = path.join(process.cwd(), "config.json");
   ```

2. **File Permissions**

   ```javascript
   // Bad
   fs.chmodSync('script.js', '755');

   // Good
   // Use shebang and let npm handle permissions
   #!/usr/bin/env node
   ```

3. **Shell Commands**

   ```javascript
   // Bad
   exec("rm -rf dir");

   // Good
   await fs.remove("dir");
   ```

4. **Environment Variables**

   ```javascript
   // Bad
   const home = process.env.HOME;

   // Good
   const home = os.homedir();
   ```

## Publishing

1. Update version:

```bash
npm version <patch|minor|major>
```

2. Build and test:

```bash
npm run build
npm test
```

3. Publish:

```bash
npm publish
```

The package will be executable on all platforms without additional setup.



--- File: readme.md ---

# Quicky CLI

A powerful CLI tool for streamlined deployment and management of Next.js applications, featuring automated deployments, custom domain management, SSL certification, and comprehensive project lifecycle management.

![Version](https://img.shields.io/npm/v/quicky)
![License](https://img.shields.io/npm/l/quicky)
![Downloads](https://img.shields.io/npm/dm/quicky)

## Features

### Core Functionality

- 🚀 **Automated Deployment**: Deploy Next.js projects directly from GitHub repositories
- 🔄 **Continuous Deployment**: Automatic updates via GitHub webhooks
- 📦 **Multiple Package Managers**: Support for npm and Bun
- 🛡️ **Process Management**: Built-in PM2 integration for reliable process management

### Domain Management

- 🌐 **Custom Domains**: Easy domain and subdomain configuration
- 🔒 **SSL Certificates**: Automated Let's Encrypt SSL certificate management
- 🚦 **Load Balancing**: Built-in Nginx configuration with rate limiting
- 🔍 **Health Checks**: Automatic domain health monitoring

### Development Experience

- 🔧 **Environment Management**: Secure handling of environment variables
- 📊 **Monitoring**: Real-time status monitoring and logging
- 🔄 **Version Control**: Automated updates and rollbacks
- 🛠️ **Project Management**: Complete project lifecycle management

## Prerequisites

### Server Requirements

- Ubuntu Linux server (18.04 LTS or newer)
- Minimum 1GB RAM (2GB recommended)
- 20GB storage space
- Public IPv4 address

### System Dependencies

```bash
# Update package list
sudo apt update

# Install Node.js and npm
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt install -y nodejs

# Verify installation
node --version  # Should be 18.x or newer
npm --version   # Should be 8.x or newer
```

## Installation

Install Quicky globally using npm:

```bash
sudo npm install -g quicky
```

Or using npx (recommended for latest version):

```bash
npx quicky@latest install
```

## Getting Started

### 1. Initialize Quicky

```bash
quicky init
```

You'll need:

- GitHub username
- GitHub personal access token ([create one here](https://github.com/settings/tokens))
- Preferred package manager (npm/bun)

### 2. Deploy Your First Project

```bash
quicky deploy
```

Interactive prompts will guide you through:

- Repository selection
- Port configuration
- Environment setup
- Domain configuration (optional)

### 3. Manage Projects

```bash
quicky list     # View all projects
quicky manage   # Manage specific projects
```

## Command Reference

### Core Commands

```bash
quicky init           # Initialize Quicky
quicky deploy         # Deploy a new project
quicky list          # List all projects
quicky manage        # Manage projects
quicky update <pid>  # Update specific project
```

### Domain Management

```bash
quicky domains add <domain>     # Add new domain
quicky domains list            # List all domains
quicky domains remove <domain> # Remove domain
quicky domains status         # Check domain health
```

### Webhook Management

```bash
quicky webhooks              # Configure webhook server
quicky webhooks status      # Check webhook status
quicky webhooks logs        # View webhook logs
```

### System Commands

```bash
quicky upgrade              # Upgrade Quicky CLI
quicky uninstall           # Remove Quicky
```

## Configuration

### Directory Structure

```
~/.quicky/
├── config.json           # Main configuration
├── projects/            # Project files
├── webhook/            # Webhook server
├── backups/            # Configuration backups
└── logs/               # System logs
```

### Environment Variables

```bash
# Optional environment variables
QUICKY_LOG_LEVEL=info    # Logging level
QUICKY_NO_UPDATE=true    # Disable update checks
QUICKY_DEBUG=true        # Enable debug mode
```

## Project Configuration

Example `config.json`:

```json
{
  "version": "1.0",
  "github": {
    "username": "your-username",
    "access_token": "your-token"
  },
  "projects": [],
  "domains": [],
  "webhook": {
    "port": 9000,
    "secret": "webhook-secret"
  },
  "packageManager": "npm",
  "email": "your@email.com"
}
```

## Domain Configuration

1. Add DNS Records:

   ```
   Type  Name          Value
   A     example.com   <Your-Server-IP>
   A     *.example.com <Your-Server-IP>  # For subdomains
   ```

2. Configure Domain:
   ```bash
   quicky domains add example.com
   ```

## Advanced Usage

### Custom Nginx Configuration

```bash
quicky domains add example.com --custom-nginx
```

This opens your default editor with the Nginx configuration template.

### SSL Certificate Management

```bash
quicky domains ssl renew        # Force SSL renewal
quicky domains ssl status       # Check SSL status
```

### Process Management

```bash
quicky manage                   # Interactive management
quicky manage --pid <pid> --action <action>  # Direct command
```

Available actions:

- `start`: Start project
- `stop`: Stop project
- `restart`: Restart project
- `update`: Update project
- `delete`: Remove project
- `logs`: View logs
- `env`: Update environment variables

## Error Handling

Common error solutions:

1. Port already in use:

   ```bash
   quicky manage --pid <pid> --port <new-port>
   ```

2. Domain configuration issues:

   ```bash
   quicky domains fix <domain>
   ```

3. SSL certificate problems:
   ```bash
   quicky domains ssl renew --force
   ```

## Development

### Setting Up Development Environment

```bash
# Clone repository
git clone https://github.com/alohe/quicky.git
cd quicky

# Install dependencies
npm install

# Run tests
npm test

# Build project
npm run build
```

### Running Tests

```bash
# Run all tests
npm test

# Run specific tests
npm test -- --grep "domain"

# Generate coverage report
npm run test:coverage
```

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [`LICENSE`](LICENSE) file for details.

## Support

- Documentation: [https://quicky.dev/docs](https://quicky.dev/docs)
- Issues: [GitHub Issues](https://github.com/alohe/quicky/issues)
- Discussions: [GitHub Discussions](https://github.com/alohe/quicky/discussions)
- Twitter: [@alemalohe](https://twitter.com/alemalohe)

## Acknowledgments

- [Next.js](https://nextjs.org/) - The React Framework
- [PM2](https://pm2.keymetrics.io/) - Process Manager
- [Nginx](https://nginx.org/) - Web Server
- [Let's Encrypt](https://letsencrypt.org/) - SSL Certificates

## Author

- Made with ❤️ by [Alohe](https://github.com/alohe)

Feel free to reach out to me on 𝕏 [@alemalohe](https://x.com/alemalohe) if you have any questions or feedback!

## Contributing

Contributions are welcome! Please read the CONTRIBUTING file for guidelines on how to get started.



--- File: src\cli.js ---

#!/usr/bin/env node
import "../src/index.js";



--- File: src\commands\deploy.js ---

// src/commands/deploy.js
import { Command } from "commander";
import inquirer from "inquirer";
import { ConfigManager } from "../lib/configManager.js";
import { ProjectManager } from "../lib/projectManager.js";
import { SystemService } from "../services/system.js";
import { ERROR_CODES, QuickyError } from "../utils/errors.js";
import { logger } from "../utils/logger.js";
import { findAvailablePort } from "../utils/network.js";
import { ValidationService } from "../utils/validation.js";

export const deployCommand = new Command("deploy")
  .description("Deploy a Next.js project from GitHub")
  .option("--owner <owner>", "GitHub repository owner")
  .option("--repo <repo>", "GitHub repository name")
  .option("--port <port>", "Port to deploy the application")
  .option("--branch <branch>", "Branch to deploy", "main")
  .option("--pm <package-manager>", "Package manager to use (npm|bun)")
  .action(async (options) => {
    try {
      // Ensure system dependencies
      await SystemService.ensureDependencies();
      await SystemService.checkSystemResources();

      const configManager = new ConfigManager();
      const projectManager = new ProjectManager(configManager);

      // Validate GitHub configuration
      if (!configManager.config.github?.access_token) {
        throw new QuickyError(
          ERROR_CODES.GITHUB.AUTH_FAILED,
          "GitHub token not found. Please run 'quicky init' first."
        );
      }

      // Collect deployment information
      let { owner, repo, port, branch, pm } = options;

      if (!owner || !repo || !port) {
        const answers = await inquirer.prompt([
          {
            name: "owner",
            message: "Enter the GitHub repository owner:",
            default: owner || configManager.config.github.username,
            when: !owner,
            validate: (input) => input.trim().length > 0 || "Owner is required",
          },
          {
            name: "repo",
            message: "Enter the GitHub repository name:",
            when: !repo,
            validate: (input) => input.trim().length > 0 || "Repository name is required",
          },
          {
            name: "port",
            message: "Enter the port to deploy the application:",
            when: !port,
            default: async () => await findAvailablePort(),
            validate: (input) => ValidationService.validatePort(input).isValid,
          },
          {
            name: "branch",
            message: "Enter the branch to deploy:",
            default: branch || "main",
            when: !branch,
          },
          {
            type: "list",
            name: "pm",
            message: "Choose package manager:",
            choices: ["npm", "bun"],
            default: pm || configManager.config.packageManager,
            when: !pm,
          },
        ]);

        owner = answers.owner || owner;
        repo = answers.repo || repo;
        port = answers.port || port;
        branch = answers.branch || branch;
        pm = answers.pm || pm;
      }

      // Check if project already exists
      const existingProject = configManager.config.projects.find((p) => p.repo === repo);
      if (existingProject) {
        throw new QuickyError(
          ERROR_CODES.PROJECT.DEPLOY_FAILED,
          `Project ${repo} already exists. Use 'quicky manage' to manage it.`
        );
      }

      // Deploy the project
      const spinner = logger.spinner("Deploying project...").start();
      const pid = await projectManager.deployProject({
        owner,
        repo,
        port,
        branch,
        packageManager: pm,
      });

      spinner.success({ text: `Project deployed successfully. PID: ${pid}` });

      // Display next steps
      logger.info("\nNext steps:");
      logger.info(`1. Configure a domain: ${chalk.blue("quicky domains")}`);
      logger.info(`2. View project status: ${chalk.blue("quicky list")}`);
      logger.info(`3. Manage project: ${chalk.blue("quicky manage")}\n`);
    } catch (error) {
      if (error instanceof QuickyError) {
        logger.error(`Deployment failed: ${error.message}`);
        if (error.suggestions.length > 0) {
          logger.info("\nSuggestions:");
          error.suggestions.forEach((suggestion) => logger.info(`- ${suggestion}`));
        }
      } else {
        logger.error(`Unexpected error: ${error.message}`);
      }
      process.exit(1);
    }
  });



--- File: src\commands\domains.js ---

// src/commands/domains.js
import chalk from "chalk";
import Table from "cli-table3";
import { Command } from "commander";
import inquirer from "inquirer";
import { ConfigManager } from "../lib/configManager.js";
import { DomainManager } from "../lib/domainManager.js";
import { NginxService } from "../services/nginx.js";
import { logger } from "../utils/logger.js";
import { ValidationService } from "../utils/validation.js";

export const domainsCommand = new Command("domains")
  .description("Manage domains for your projects")
  .option("-a, --add <domain>", "Add a domain")
  .option("-r, --remove <domain>", "Remove a domain")
  .option("-p, --project <pid>", "Project ID to associate domain with")
  .option("-l, --list", "List all domains")
  .option("--force-ssl", "Force SSL certificate renewal")
  .action(async (options) => {
    try {
      const configManager = new ConfigManager();
      const domainManager = new DomainManager(configManager);
      const nginxService = new NginxService();

      // If no options specified, show interactive menu
      if (!options.add && !options.remove && !options.list) {
        const { action } = await inquirer.prompt([
          {
            type: "list",
            name: "action",
            message: "What would you like to do?",
            choices: [
              { name: "List Domains", value: "list" },
              { name: "Add Domain", value: "add" },
              { name: "Remove Domain", value: "remove" },
              { name: "Check Domain Status", value: "status" },
              { name: "Fix Domain Configuration", value: "fix" },
              { name: "Renew SSL Certificates", value: "ssl" },
            ],
          },
        ]);
        options.action = action;
      }

      switch (options.action || (options.list ? "list" : options.add ? "add" : "remove")) {
        case "list":
          await handleListDomains(configManager);
          break;

        case "add":
          await handleAddDomain(domainManager, configManager, options);
          break;

        case "remove":
          await handleRemoveDomain(domainManager, options);
          break;

        case "status":
          await handleDomainStatus(domainManager);
          break;

        case "fix":
          await handleFixDomain(domainManager);
          break;

        case "ssl":
          await handleRenewSSL(domainManager);
          break;

        default:
          logger.error("Invalid action specified");
          break;
      }
    } catch (error) {
      logger.error(`Domain management failed: ${error.message}`);
      process.exit(1);
    }
  });

async function handleListDomains(configManager) {
  const domains = configManager.config.domains || [];

  if (domains.length === 0) {
    logger.info("No domains configured");
    return;
  }

  const table = new Table({
    head: [
      chalk.cyan("Domain"),
      chalk.cyan("Project"),
      chalk.cyan("Status"),
      chalk.cyan("SSL Expires"),
      chalk.cyan("Added"),
    ],
  });

  for (const domain of domains) {
    const project = configManager.getProject(domain.pid);
    const status = await nginxService.getStatus(domain.domain);
    const ssl = await sslService.getCertificateInfo(domain.domain);

    table.push([
      domain.domain,
      project ? project.repo : chalk.red("Unknown"),
      status.isEnabled ? chalk.green("Active") : chalk.red("Inactive"),
      ssl ? formatDistanceToNow(ssl.valid.to, { addSuffix: true }) : chalk.red("No SSL"),
      formatDistanceToNow(new Date(domain.added), { addSuffix: true }),
    ]);
  }

  console.log(table.toString());
}

async function handleAddDomain(domainManager, configManager, options) {
  let { domain, project: pid } = options;

  if (!domain || !pid) {
    const answers = await inquirer.prompt([
      {
        type: "list",
        name: "pid",
        message: "Select a project:",
        choices: configManager.config.projects.map((p) => ({
          name: `${p.repo} (${p.pid})`,
          value: p.pid,
        })),
        when: !pid,
      },
      {
        type: "input",
        name: "domain",
        message: "Enter domain name:",
        validate: (input) => ValidationService.validateDomain(input).isValid,
        when: !domain,
      },
    ]);

    domain = answers.domain || domain;
    pid = answers.pid || pid;
  }

  const spinner = logger.spinner(`Adding domain ${domain}...`).start();

  try {
    await domainManager.addDomain(pid, domain);
    spinner.success({ text: `Domain ${domain} added successfully` });

    logger.info("\nNext steps:");
    logger.info(`1. Ensure DNS is configured: ${domain} -> A record -> Your server IP`);
    logger.info(`2. Test your domain: https://${domain}`);
    logger.info(`3. View status: quicky domains --action status\n`);
  } catch (error) {
    spinner.fail({ text: error.message });
  }
}

async function handleRemoveDomain(domainManager, options) {
  let { domain } = options;

  if (!domain) {
    const domains = domainManager.getAllDomains();
    if (domains.length === 0) {
      logger.info("No domains configured");
      return;
    }

    const answer = await inquirer.prompt([
      {
        type: "list",
        name: "domain",
        message: "Select domain to remove:",
        choices: domains.map((d) => d.domain),
      },
    ]);

    domain = answer.domain;
  }

  const { confirm } = await inquirer.prompt([
    {
      type: "confirm",
      name: "confirm",
      message: `Are you sure you want to remove ${domain}?`,
      default: false,
    },
  ]);

  if (confirm) {
    const spinner = logger.spinner(`Removing domain ${domain}...`).start();
    try {
      await domainManager.removeDomain(domain);
      spinner.success({ text: `Domain ${domain} removed successfully` });
    } catch (error) {
      spinner.fail({ text: error.message });
    }
  }
}



--- File: src\commands\help.js ---

// src/commands/help.js
import chalk from "chalk";
import { Command } from "commander";
import { packageJson } from "../config/packageJson.js";
import { logger } from "../utils/logger.js";

const BUNNY_ART = `
 (\\(\\ 
 ( -.-) 
 o_(")(")
`;

export const helpCommand = new Command().description("Display help information").action(() => {
  logger.info(chalk.blue(BUNNY_ART));
  logger.info(`${chalk.hex("#fd6d4c").bold("Quicky")} ${chalk.hex("#f39549")("v" + packageJson.version)}`);
  logger.info(chalk.hex("#f39549")("A CLI tool to deploy Next.js projects"));

  logger.info("\nUsage:");
  logger.info(`  ${chalk.blue("quicky")} ${chalk.hex("#FFA500")("<command>")} ${chalk.green("[options]")}`);

  logger.info("\nCore Commands:");
  logger.info(`  ${chalk.hex("#cea9fe").bold("init")}        Save GitHub account details and install dependencies`);
  logger.info(`  ${chalk.blue.bold("deploy")}      Deploy a Next.js project from GitHub`);
  logger.info(`  ${chalk.blue.bold("list")}        List all deployed projects and their status`);
  logger.info(`  ${chalk.blue.bold("manage")}      Manage deployed projects (start/stop/restart/delete)`);

  logger.info("\nDomain Management:");
  logger.info(`  ${chalk.cyanBright.bold("domains")}     Configure and manage domains for your projects`);
  logger.info(`  ${chalk.cyanBright.bold("webhooks")}    Manage the webhook server for automatic deployments`);

  logger.info("\nMaintenance:");
  logger.info(`  ${chalk.hex("#fe64fa").bold("update")}      Update a specific project by PID`);
  logger.info(`  ${chalk.hex("#fe64fa").bold("upgrade")}     Upgrade Quicky CLI to the latest version`);
  logger.info(`  ${chalk.hex("#fe64fa").bold("uninstall")}   Remove Quicky and all its configurations`);

  logger.info("\nFor more information, visit: https://quicky.dev");
});



--- File: src\commands\init.js ---

// src/commands/init.js
import { Command } from "commander";
import inquirer from "inquirer";
import { ConfigManager } from "../lib/configManager.js";
import { PackageManagerService } from "../services/packageManager.js";
import { logger } from "../utils/logger.js";

export const initCommand = new Command("init")
  .description("Save your GitHub account details and install dependencies")
  .option("--username <username>", "GitHub username")
  .option("--token <token>", "GitHub personal access token")
  .option("--packageManager <packageManager>", "Package manager to use (npm|bun)")
  .action(async (cmd) => {
    const configManager = new ConfigManager();

    try {
      let { username, token, packageManager } = cmd;

      if (!username || !token || !packageManager) {
        const answers = await inquirer.prompt([
          {
            name: "username",
            message: "Enter your GitHub username:",
            default: username || configManager.config.github?.username,
          },
          {
            name: "token",
            message: "Enter your GitHub personal access token:",
            default: token || configManager.config.github?.access_token,
          },
          {
            type: "list",
            name: "packageManager",
            message: "Choose your default package manager:",
            choices: [
              { name: "npm (stable, widely supported)", value: "npm" },
              { name: "bun (faster, experimental)", value: "bun" },
            ],
            default: packageManager || configManager.config.packageManager || "npm",
          },
        ]);

        username = answers.username;
        token = answers.token;
        packageManager = answers.packageManager;
      }

      // Initialize package manager service
      const pmService = new PackageManagerService(packageManager);

      // Ensure chosen package manager is installed
      const spinner = logger.spinner("Setting up package manager...").start();
      await pmService.ensureInstalled();
      spinner.success({ text: "Package manager setup complete" });

      // Save configuration
      configManager.config.github = { username, access_token: token };
      configManager.config.packageManager = packageManager;
      configManager.saveConfig();

      logger.success("Configuration saved successfully");
      logger.info(`Default package manager set to: ${packageManager}`);

      if (packageManager === "bun") {
        logger.info("Note: Bun support is experimental. Some Next.js features might not work as expected.");
        logger.info("You can switch back to npm at any time using 'quicky init'");
      }
    } catch (error) {
      logger.error(`Initialization failed: ${error.message}`);
      process.exit(1);
    }
  });



--- File: src\commands\install.js ---

import { Command } from "commander";
import { logger } from "../utils/logger.js";
import { executeCommand } from "../utils/process.js";

export const installCommand = new Command("install").description("Install the CLI tool globally").action(async () => {
  try {
    await executeCommand("sudo npm install -g quicky");
    logger.success("Quicky has been installed globally");
  } catch (error) {
    logger.error(`Installation failed: ${error.message}`);
    process.exit(1);
  }
});



--- File: src\commands\list.js ---

// src/commands/list.js
import Table from "cli-table3";
import { Command } from "commander";
import { formatDistanceToNow } from "date-fns";
import { ConfigManager } from "../lib/configManager.js";
import { PM2Service } from "../services/pm2.js";
import { logger } from "../utils/logger.js";

export const listCommand = new Command("list")
  .description("List all deployed projects and their status")
  .option("-d, --detailed", "Show detailed information")
  .option("-f, --format <format>", "Output format (table|json)")
  .action(async (options) => {
    try {
      const configManager = new ConfigManager();
      const pm2Service = new PM2Service();

      if (!configManager.config.projects.length) {
        logger.info("No projects deployed yet");
        logger.info(`Use ${chalk.blue("quicky deploy")} to deploy your first project`);
        return;
      }

      if (options.format === "json") {
        const projects = await Promise.all(
          configManager.config.projects.map(async (project) => ({
            ...project,
            status: await pm2Service.getStatus(project.repo),
            domains: configManager.getProjectDomains(project.pid),
          }))
        );
        console.log(JSON.stringify(projects, null, 2));
        return;
      }

      // Create table
      const table = new Table({
        head: [
          chalk.cyan.bold("PID"),
          chalk.cyan.bold("Repository"),
          chalk.cyan.bold("Port"),
          chalk.cyan.bold("Status"),
          chalk.cyan.bold("Domains"),
          chalk.cyan.bold("Last Updated"),
        ],
        style: { head: ["cyan"] },
      });

      // Populate table
      for (const project of configManager.config.projects) {
        const status = await pm2Service.getStatus(project.repo);
        const domains = configManager.getProjectDomains(project.pid);

        table.push([
          chalk.yellow(project.pid),
          `${project.owner}/${project.repo}`,
          project.port,
          status === "online" ? chalk.green("●") + " running" : chalk.red("●") + " stopped",
          domains.length ? domains.join("\n") : chalk.gray("none"),
          formatDistanceToNow(new Date(project.last_updated), { addSuffix: true }),
        ]);
      }

      console.log(table.toString());

      if (options.detailed) {
        // Show system information
        logger.info("\nSystem Information:");
        const resources = await SystemService.checkSystemResources();
        console.log(`CPU Cores: ${resources.cpuCores}`);
        console.log(`Memory: ${resources.totalMem}MB`);
        console.log(`Disk Space: ${resources.availableSpace}%`);
      }
    } catch (error) {
      logger.error(`Failed to list projects: ${error.message}`);
      process.exit(1);
    }
  });



--- File: src\commands\manage.js ---

// src/commands/manage.js
import { Command } from "commander";
import inquirer from "inquirer";
import { ConfigManager } from "../lib/configManager.js";
import { ProjectManager } from "../lib/projectManager.js";
import { logger } from "../utils/logger.js";

export const manageCommand = new Command("manage")
  .description("Manage deployed projects")
  .option("-p, --pid <pid>", "Project ID to manage")
  .option("-a, --action <action>", "Action to perform (start|stop|restart|update|delete)")
  .action(async (options) => {
    try {
      const configManager = new ConfigManager();
      const projectManager = new ProjectManager(configManager);

      if (!configManager.config.projects.length) {
        throw new Error("No projects found to manage");
      }

      let { pid, action } = options;

      if (!pid || !action) {
        const answers = await inquirer.prompt([
          {
            type: "list",
            name: "pid",
            message: "Select a project to manage:",
            choices: configManager.config.projects.map((p) => ({
              name: `${p.repo} (${p.pid})`,
              value: p.pid,
            })),
            when: !pid,
          },
          {
            type: "list",
            name: "action",
            message: "What action would you like to perform?",
            choices: [
              { name: "Start Project", value: "start" },
              { name: "Stop Project", value: "stop" },
              { name: "Restart Project", value: "restart" },
              { name: "Update Project", value: "update" },
              { name: "Delete Project", value: "delete" },
              { name: "View Logs", value: "logs" },
              { name: "Edit Environment", value: "env" },
            ],
            when: !action,
          },
        ]);

        pid = answers.pid || pid;
        action = answers.action || action;
      }

      const project = configManager.getProject(pid);
      if (!project) {
        throw new Error(`Project with PID ${pid} not found`);
      }

      const spinner = logger.spinner(`Performing ${action}...`).start();

      switch (action) {
        case "start":
        case "stop":
        case "restart":
          await projectManager.pm2Service[action](project.repo);
          break;

        case "update":
          await projectManager.updateProject(pid);
          break;

        case "delete":
          const { confirmDelete } = await inquirer.prompt([
            {
              type: "confirm",
              name: "confirmDelete",
              message: `Are you sure you want to delete ${project.repo}?`,
              default: false,
            },
          ]);

          if (confirmDelete) {
            await projectManager.deleteProject(pid);
          } else {
            logger.info("Deletion cancelled");
          }
          break;

        case "logs":
          spinner.stop();
          await projectManager.pm2Service.logs(project.repo);
          break;

        case "env":
          spinner.stop();
          await projectManager.updateEnvironment(pid);
          break;

        default:
          throw new Error(`Unknown action: ${action}`);
      }

      spinner.success({ text: `Action ${action} completed successfully` });
    } catch (error) {
      logger.error(`Management action failed: ${error.message}`);
      process.exit(1);
    }
  });



--- File: src\commands\uninstall.js ---

// src/commands/uninstall.js
import { Command } from "commander";
import fs from "fs-extra";
import { PATHS } from "../config/constants.js";
import { ConfigManager } from "../lib/configManager.js";
import { ProjectManager } from "../lib/projectManager.js";
import { executeCommand } from "../utils/process.js";

export const uninstallCommand = new Command("uninstall")
  .description("Uninstall Quicky CLI and clean up resources")
  .option("-f, --force", "Skip confirmation")
  .action(async (options) => {
    try {
      if (!options.force) {
        logger.warning("\n⚠️  WARNING: This action is irreversible!");
        logger.warning("All projects, configurations, and deployed applications will be removed.");

        const { confirm } = await inquirer.prompt([
          {
            type: "confirm",
            name: "confirm",
            message: "Are you sure you want to uninstall Quicky?",
            default: false,
          },
        ]);

        if (!confirm) {
          logger.info("Uninstallation cancelled");
          return;
        }
      }

      const spinner = logger.spinner("Uninstalling Quicky...").start();

      const configManager = new ConfigManager();
      const projectManager = new ProjectManager(configManager);

      // Stop and remove all PM2 processes
      spinner.update({ text: "Stopping all projects..." });
      for (const project of configManager.config.projects) {
        try {
          await projectManager.pm2Service.delete(project.repo);
        } catch (error) {
          logger.warning(`Failed to stop project ${project.repo}: ${error.message}`);
        }
      }

      // Remove webhook server if running
      if (configManager.config.webhook?.pm2Name) {
        try {
          await projectManager.pm2Service.delete(configManager.config.webhook.pm2Name);
        } catch (error) {
          logger.warning(`Failed to stop webhook server: ${error.message}`);
        }
      }

      // Remove Nginx configurations
      spinner.update({ text: "Removing domain configurations..." });
      const domainManager = new DomainManager(configManager);
      for (const domain of configManager.config.domains || []) {
        try {
          await domainManager.removeDomain(domain.domain);
        } catch (error) {
          logger.warning(`Failed to remove domain ${domain.domain}: ${error.message}`);
        }
      }

      // Remove project directories
      spinner.update({ text: "Removing project files..." });
      await fs.remove(PATHS.DEFAULT_FOLDER);

      // Uninstall the CLI
      spinner.update({ text: "Removing Quicky CLI..." });
      await executeCommand("sudo npm uninstall -g quicky");

      spinner.success({ text: "Quicky has been successfully uninstalled" });
    } catch (error) {
      logger.error(`Uninstallation failed: ${error.message}`);
      process.exit(1);
    }
  });



--- File: src\commands\update.js ---

// src/commands/update.js
import { Command } from "commander";
import { ConfigManager } from "../lib/configManager.js";
import { ProjectManager } from "../lib/projectManager.js";
import { logger } from "../utils/logger.js";

export const updateCommand = new Command("update")
  .description("Update a project")
  .argument("[pid]", "Project ID to update")
  .option("-e, --env", "Update environment variables")
  .option("-b, --branch <branch>", "Branch to update from")
  .option("--no-build", "Skip build step")
  .action(async (pid, options) => {
    try {
      const configManager = new ConfigManager();
      const projectManager = new ProjectManager(configManager);

      // If no PID provided, show project selection
      if (!pid) {
        const { selectedPid } = await inquirer.prompt([
          {
            type: "list",
            name: "selectedPid",
            message: "Select a project to update:",
            choices: configManager.config.projects.map((p) => ({
              name: `${p.repo} (${p.pid})`,
              value: p.pid,
            })),
          },
        ]);
        pid = selectedPid;
      }

      const project = configManager.getProject(pid);
      if (!project) {
        throw new Error(`Project with PID ${pid} not found`);
      }

      const spinner = logger.spinner(`Updating ${project.repo}...`).start();

      try {
        // Update environment variables if requested
        if (options.env) {
          spinner.update({ text: "Updating environment variables..." });
          await projectManager.updateEnvironment(pid);
        }

        // Perform project update
        await projectManager.updateProject(pid, {
          branch: options.branch,
          skipBuild: !options.build,
        });

        spinner.success({ text: `Project ${project.repo} updated successfully` });

        // Show status information
        const status = await projectManager.pm2Service.getStatus(project.repo);
        logger.info("\nProject Status:");
        logger.info(`Status: ${status === "online" ? chalk.green("Running") : chalk.red("Stopped")}`);
        logger.info(`Port: ${project.port}`);
        logger.info(`Last Updated: ${formatDistanceToNow(new Date(), { addSuffix: true })}`);
      } catch (error) {
        spinner.fail({ text: error.message });
        throw error;
      }
    } catch (error) {
      logger.error(`Update failed: ${error.message}`);
      process.exit(1);
    }
  });



--- File: src\commands\upgrade.js ---

// src/commands/upgrade.js
import { Command } from "commander";
import latestVersion from "latest-version";
import semver from "semver";
import { packageJson } from "../config/packageJson.js";
import { logger } from "../utils/logger.js";
import { executeCommand } from "../utils/process.js";

export const upgradeCommand = new Command("upgrade")
  .description("Upgrade Quicky to the latest version")
  .option("-f, --force", "Force upgrade even if already on latest version")
  .action(async (options) => {
    try {
      const spinner = logger.spinner("Checking for updates...").start();
      const latest = await latestVersion("quicky");

      if (semver.gt(latest, packageJson.version) || options.force) {
        spinner.update({ text: `Upgrading from v${packageJson.version} to v${latest}...` });

        // Backup configuration
        const configManager = new ConfigManager();
        await configManager.backupConfig();

        // Perform upgrade
        await executeCommand("sudo npm install -g quicky@latest");

        // Verify upgrade
        const newVersion = (await executeCommand("quicky -v", { encoding: "utf8" })).trim();

        if (semver.eq(newVersion, latest)) {
          spinner.success({ text: `Upgraded successfully to v${latest}` });

          // Check for breaking changes
          if (semver.major(latest) > semver.major(packageJson.version)) {
            logger.warning("This is a major version upgrade. Please check the release notes for breaking changes.");
            logger.info("Release notes: https://github.com/alohe/quicky/releases");
          }
        } else {
          throw new Error("Upgrade verification failed");
        }
      } else {
        spinner.info({ text: `Already on the latest version (${packageJson.version})` });
      }
    } catch (error) {
      logger.error(`Upgrade failed: ${error.message}`);
      process.exit(1);
    }
  });



--- File: src\commands\webhooks.js ---

// src/commands/webhooks.js
import { Command } from "commander";
import fs from "fs-extra";
import inquirer from "inquirer";
import path from "path";
import { v4 as uuidv4 } from "uuid";
import { PATHS, PM2_NAMES } from "../config/constants.js";
import { ConfigManager } from "../lib/configManager.js";
import { PM2Service } from "../services/pm2.js";
import { WebhookService } from "../services/webhook.js";
import { logger } from "../utils/logger.js";
import { findAvailablePort } from "../utils/network.js";
import { ValidationService } from "../utils/validation.js";

export const webhooksCommand = new Command("webhooks")
  .description("Manage webhook server and project webhooks")
  .option("-a, --action <action>", "Action to perform (status|start|stop|restart|logs|configure)")
  .option("-p, --port <port>", "Port for webhook server")
  .option("--url <url>", "Webhook URL")
  .action(async (options) => {
    try {
      const configManager = new ConfigManager();
      const pm2Service = new PM2Service();

      const isWebhookServerRunning = async () => {
        try {
          const status = await pm2Service.getStatus(PM2_NAMES.WEBHOOK_SERVER);
          return status === "online";
        } catch {
          return false;
        }
      };

      // If no action specified, determine based on server status
      if (!options.action) {
        const isRunning = await isWebhookServerRunning();
        if (isRunning) {
          const { action } = await inquirer.prompt([
            {
              type: "list",
              name: "action",
              message: "Webhook server is running. What would you like to do?",
              choices: [
                { name: "View Status", value: "status" },
                { name: "View Logs", value: "logs" },
                { name: "Restart Server", value: "restart" },
                { name: "Stop Server", value: "stop" },
                { name: "Reconfigure", value: "configure" },
                { name: "Update Project Webhooks", value: "update" },
              ],
            },
          ]);
          options.action = action;
        } else {
          const { action } = await inquirer.prompt([
            {
              type: "list",
              name: "action",
              message: "Webhook server is not running. What would you like to do?",
              choices: [
                { name: "Start Server", value: "start" },
                { name: "Configure and Start", value: "configure" },
              ],
            },
          ]);
          options.action = action;
        }
      }

      switch (options.action) {
        case "status":
          await handleStatus(pm2Service);
          break;

        case "start":
          await handleStart(configManager, pm2Service);
          break;

        case "stop":
          await handleStop(pm2Service);
          break;

        case "restart":
          await handleRestart(pm2Service);
          break;

        case "logs":
          await handleLogs(pm2Service);
          break;

        case "configure":
          await handleConfigure(configManager, pm2Service, options);
          break;

        case "update":
          await handleUpdateWebhooks(configManager);
          break;

        default:
          throw new Error(`Unknown action: ${options.action}`);
      }
    } catch (error) {
      logger.error(`Webhook management failed: ${error.message}`);
      process.exit(1);
    }
  });

async function handleStatus(pm2Service) {
  const spinner = logger.spinner("Checking webhook server status...").start();
  try {
    const status = await pm2Service.describe(PM2_NAMES.WEBHOOK_SERVER);
    spinner.stop();

    if (status) {
      const table = new Table({
        head: ["Name", "Status", "CPU", "Memory", "Uptime"],
        style: { head: ["cyan"] },
      });

      table.push([
        PM2_NAMES.WEBHOOK_SERVER,
        status.pm2_env.status === "online" ? chalk.green("online") : chalk.red("stopped"),
        `${status.monit.cpu}%`,
        `${Math.round(status.monit.memory / 1024 / 1024)}MB`,
        formatDistanceToNow(new Date(status.pm2_env.pm_uptime)),
      ]);

      console.log(table.toString());
    } else {
      logger.info("Webhook server is not running");
    }
  } catch (error) {
    spinner.fail({ text: `Failed to get status: ${error.message}` });
  }
}

async function handleStart(configManager, pm2Service) {
  if (!configManager.config.webhook) {
    logger.error("Webhook server not configured. Please run 'quicky webhooks --action configure' first");
    return;
  }

  const spinner = logger.spinner("Starting webhook server...").start();
  try {
    await pm2Service.start({
      name: PM2_NAMES.WEBHOOK_SERVER,
      script: path.join(PATHS.WEBHOOK_DIR, "index.js"),
      env: {
        WEBHOOK_PORT: configManager.config.webhook.port,
        WEBHOOK_SECRET: configManager.config.webhook.secret,
        NODE_ENV: "production",
      },
    });
    spinner.success({ text: "Webhook server started successfully" });
  } catch (error) {
    spinner.fail({ text: `Failed to start webhook server: ${error.message}` });
  }
}

async function handleStop(pm2Service) {
  const spinner = logger.spinner("Stopping webhook server...").start();
  try {
    await pm2Service.stop(PM2_NAMES.WEBHOOK_SERVER);
    spinner.success({ text: "Webhook server stopped successfully" });
  } catch (error) {
    spinner.fail({ text: `Failed to stop webhook server: ${error.message}` });
  }
}

async function handleRestart(pm2Service) {
  const spinner = logger.spinner("Restarting webhook server...").start();
  try {
    await pm2Service.restart(PM2_NAMES.WEBHOOK_SERVER);
    spinner.success({ text: "Webhook server restarted successfully" });
  } catch (error) {
    spinner.fail({ text: `Failed to restart webhook server: ${error.message}` });
  }
}

async function handleLogs(pm2Service) {
  try {
    const { logType } = await inquirer.prompt([
      {
        type: "list",
        name: "logType",
        message: "Which logs would you like to see?",
        choices: [
          { name: "All Logs", value: "all" },
          { name: "Error Logs Only", value: "error" },
          { name: "Last 100 Lines", value: "recent" },
        ],
      },
    ]);

    const options = {
      lines: logType === "recent" ? 100 : undefined,
      error: logType === "error",
    };

    await pm2Service.logs(PM2_NAMES.WEBHOOK_SERVER, options);
  } catch (error) {
    logger.error(`Failed to show logs: ${error.message}`);
  }
}

async function handleConfigure(configManager, pm2Service, options) {
  const spinner = logger.spinner("Configuring webhook server...").start();

  try {
    // Stop existing server if running
    const isRunning = (await pm2Service.getStatus(PM2_NAMES.WEBHOOK_SERVER)) === "online";
    if (isRunning) {
      await pm2Service.stop(PM2_NAMES.WEBHOOK_SERVER);
    }

    // Get webhook URL and port
    let { webhookUrl, port } = options;

    if (!webhookUrl || !port) {
      spinner.stop();
      const answers = await inquirer.prompt([
        {
          type: "input",
          name: "webhookUrl",
          message: "Enter the webhook URL (e.g., hooks.example.com):",
          validate: (input) => ValidationService.validateDomain(input).isValid,
          when: !options.url,
        },
        {
          type: "input",
          name: "port",
          message: "Enter the webhook server port:",
          default: async () => await findAvailablePort(9000),
          validate: (input) => ValidationService.validatePort(input).isValid,
          when: !options.port,
        },
      ]);

      webhookUrl = answers.webhookUrl || webhookUrl;
      port = answers.port || port;
    }

    spinner.start();

    // Generate new webhook secret
    const webhookSecret = uuidv4();

    // Update configuration
    configManager.config.webhook = {
      url: `https://${webhookUrl}/webhook`,
      port: parseInt(port),
      secret: webhookSecret,
    };

    configManager.saveConfig();

    // Set up webhook server files
    await fs.ensureDir(PATHS.WEBHOOK_DIR);
    const webhookService = new WebhookService(configManager.config);

    // Clone and setup webhook server repository
    await webhookService.setupWebhookServer();

    // Update all project webhooks with new configuration
    await webhookService.updateAllWebhooks(configManager.config.webhook.url, configManager.config.webhook.secret);

    // Start webhook server
    await handleStart(configManager, pm2Service);

    spinner.success({ text: "Webhook server configured and started successfully" });

    logger.info("\nWebhook Configuration:");
    logger.info(`URL: ${configManager.config.webhook.url}`);
    logger.info(`Port: ${configManager.config.webhook.port}`);
    logger.info("Secret: " + "*".repeat(8));
  } catch (error) {
    spinner.fail({ text: `Failed to configure webhook server: ${error.message}` });
  }
}

async function handleUpdateWebhooks(configManager) {
  const spinner = logger.spinner("Updating project webhooks...").start();

  try {
    if (!configManager.config.webhook) {
      throw new Error("Webhook server not configured");
    }

    const webhookService = new WebhookService(configManager.config);
    await webhookService.updateAllWebhooks(configManager.config.webhook.url, configManager.config.webhook.secret);

    spinner.success({ text: "Project webhooks updated successfully" });
  } catch (error) {
    spinner.fail({ text: `Failed to update webhooks: ${error.message}` });
  }
}

export default webhooksCommand;



--- File: src\config\constants.js ---

// constants.js
import os from "os";
import path from "path";

export const PATHS = {
  HOME: os.homedir(),
  DEFAULT_FOLDER: path.join(os.homedir(), ".quicky"),
  PROJECTS_DIR: path.join(os.homedir(), ".quicky/projects"),
  TEMP_DIR: path.join(os.homedir(), ".quicky/temp"),
  CONFIG_PATH: path.join(os.homedir(), ".quicky/config.json"),
  WEBHOOK_DIR: path.join(os.homedir(), ".quicky/webhook"),
};

export const PM2_NAMES = {
  WEBHOOK_SERVER: "quicky-webhook-server",
};

export const ERROR_MESSAGES = {
  NO_GITHUB_TOKEN: "GitHub access token not found. Please run the init command first.",
  NO_PROJECTS: "No projects found.",
  INVALID_PORT: "Please enter a valid port number between 1 and 65535.",
};



--- File: src\config\packageJson.js ---

import fs from "fs-extra";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const packagePath = path.resolve(__dirname, "../../package.json");

export const getPackageJson = () => {
  return JSON.parse(fs.readFileSync(packagePath, "utf-8"));
};

export const packageJson = getPackageJson();



--- File: src\index.js ---

import { program } from "commander";
import { deployCommand } from "./commands/deploy.js";
import { domainsCommand } from "./commands/domains.js";
import { initCommand } from "./commands/init.js";
import { installCommand } from "./commands/install.js";
import { listCommand } from "./commands/list.js";
import { manageCommand } from "./commands/manage.js";
import { uninstallCommand } from "./commands/uninstall.js";
import { updateCommand } from "./commands/update.js";
import { upgradeCommand } from "./commands/upgrade.js";
import { webhooksCommand } from "./commands/webhooks.js";
import { packageJson } from "./config/packageJson.js";
import { ensureDirectories } from "./utils/fileSystem.js";
import { formatOutput, logger } from "./utils/logger.js";
import { checkForUpdates } from "./utils/updateChecker.js";

// Ensure required directories exist
ensureDirectories();

// CLI Header Art
const HEADER_ART = `
 (\\(\\ 
 ( -.-) Quicky CLI
 o_(")(")
`;

// Version and description
program
  .version(packageJson.version)
  .description("A CLI tool to deploy Next.js projects")
  .addCommand(initCommand)
  .addCommand(deployCommand)
  .addCommand(manageCommand)
  .addCommand(domainsCommand)
  .addCommand(webhooksCommand)
  .addCommand(updateCommand)
  .addCommand(listCommand)
  .addCommand(installCommand)
  .addCommand(upgradeCommand)
  .addCommand(uninstallCommand);

// Post-action hook for update checking
program.hook("postAction", async () => {
  const excludedCommands = ["upgrade", "uninstall"];
  const command = process.argv[2];

  if (!excludedCommands.includes(command)) {
    await checkForUpdates();
  }
});

// Default command (show help)
program.action(() => {
  console.log(formatOutput.highlight(HEADER_ART));
  program.help();
});

// Error handling for unknown commands
program.on("command:*", () => {
  logger.error(`Invalid command: ${program.args.join(" ")}`);
  console.log("");
  program.help();
});

// Global error handling
process.on("unhandledRejection", (error) => {
  logger.error(`Unhandled promise rejection: ${error.message}`);
  process.exit(1);
});

process.on("uncaughtException", (error) => {
  logger.error(`Uncaught exception: ${error.message}`);
  process.exit(1);
});

// Parse command line arguments
program.parse(process.argv);



--- File: src\lib\configManager.js ---

// src/lib/configManager.js - Enhanced Version
import fs from "fs-extra";
import path from "path";
import { PATHS } from "../config/constants.js";
import { ERROR_CODES, QuickyError } from "../utils/errors.js";
import { logger } from "../utils/logger.js";

export class ConfigManager {
  constructor() {
    this.configPath = PATHS.CONFIG_PATH;
    this.backupPath = path.join(PATHS.DEFAULT_FOLDER, "backups");
    this.config = this.loadConfig();
  }

  loadConfig() {
    try {
      if (!fs.existsSync(this.configPath)) {
        return this.createDefaultConfig();
      }

      const config = JSON.parse(fs.readFileSync(this.configPath, "utf-8"));
      return this.migrateConfig(config);
    } catch (error) {
      throw new QuickyError(ERROR_CODES.CONFIG.LOAD_FAILED, `Failed to load configuration: ${error.message}`);
    }
  }

  saveConfig() {
    try {
      // Create backup before saving
      this.backupConfig();

      fs.writeFileSync(this.configPath, JSON.stringify(this.config, null, 2));
    } catch (error) {
      throw new QuickyError(ERROR_CODES.CONFIG.SAVE_FAILED, `Failed to save configuration: ${error.message}`);
    }
  }

  getProject(pid) {
    return this.config.projects.find((project) => project.pid === pid);
  }

  addProject(project) {
    if (this.getProject(project.pid)) {
      throw new QuickyError(ERROR_CODES.CONFIG.DUPLICATE_PROJECT, `Project with PID ${project.pid} already exists`);
    }

    this.config.projects.push(project);
    this.saveConfig();
  }

  updateProject(pid, updates) {
    const index = this.config.projects.findIndex((p) => p.pid === pid);
    if (index === -1) {
      throw new QuickyError(ERROR_CODES.CONFIG.PROJECT_NOT_FOUND, `Project with PID ${pid} not found`);
    }

    this.config.projects[index] = {
      ...this.config.projects[index],
      ...updates,
    };

    this.saveConfig();
  }

  removeProject(pid) {
    const initialLength = this.config.projects.length;
    this.config.projects = this.config.projects.filter((p) => p.pid !== pid);

    if (this.config.projects.length === initialLength) {
      throw new QuickyError(ERROR_CODES.CONFIG.PROJECT_NOT_FOUND, `Project with PID ${pid} not found`);
    }

    // Remove associated domains
    if (this.config.domains) {
      this.config.domains = this.config.domains.filter((d) => d.pid !== pid);
    }

    this.saveConfig();
  }

  getProjectDomains(pid) {
    return (this.config.domains || []).filter((domain) => domain.pid === pid).map((domain) => domain.domain);
  }

  async backupConfig() {
    try {
      await fs.ensureDir(this.backupPath);
      const backupFile = path.join(this.backupPath, `config-${Date.now()}.json`);
      await fs.copy(this.configPath, backupFile);

      // Keep only last 5 backups
      const backups = await fs.readdir(this.backupPath);
      if (backups.length > 5) {
        const oldestBackup = backups.sort()[0];
        await fs.remove(path.join(this.backupPath, oldestBackup));
      }
    } catch (error) {
      logger.warning(`Failed to create config backup: ${error.message}`);
    }
  }

  async restoreConfig(backupDate) {
    const backups = await fs.readdir(this.backupPath);
    const backup = backups.find((b) => b.includes(backupDate));

    if (!backup) {
      throw new QuickyError(ERROR_CODES.CONFIG.BACKUP_NOT_FOUND, "Backup not found");
    }

    await fs.copy(path.join(this.backupPath, backup), this.configPath);

    this.config = this.loadConfig();
  }

  createDefaultConfig() {
    return {
      version: "1.0",
      projects: [],
      domains: [],
      webhook: null,
      github: null,
      packageManager: "npm",
      email: null,
    };
  }

  migrateConfig(config) {
    // Add version if missing
    if (!config.version) {
      config.version = "1.0";
    }

    // Migrate pre-1.0 configurations
    if (semver.lt(config.version, "1.0")) {
      // Add any necessary migrations here
      config = this.migratePreV1Config(config);
    }

    return config;
  }

  migratePreV1Config(config) {
    // Example migration logic
    return {
      ...config,
      version: "1.0",
      domains: config.domains || [],
      webhook: config.webhook || null,
      packageManager: config.packageManager || "npm",
    };
  }
}



--- File: src\lib\domainManager.js ---

// src/lib/domainManager.js
import fs from "fs-extra";
import { DomainVerificationService } from "../services/domainVerification.js";
import { NginxService } from "../services/nginx.js";
import { SSLService } from "../services/ssl.js";
import { logger } from "../utils/logger.js";

export class DomainManager {
  constructor(configManager) {
    this.configManager = configManager;
    this.nginxService = new NginxService();
    this.sslService = new SSLService(configManager.config.email);
    this.domainVerification = new DomainVerificationService();
  }

  async validateDomainAvailability(domain) {
    const nginxConfigPath = `/etc/nginx/sites-available/${domain}`;
    const nginxSymlinkPath = `/etc/nginx/sites-enabled/${domain}`;
    const existingNginxConfig = fs.existsSync(nginxConfigPath) || fs.existsSync(nginxSymlinkPath);

    // Check if domain exists in config.json
    const domainExistsInConfig = (this.configManager.config.domains || []).some((d) => d.domain === domain);

    if (existingNginxConfig) {
      if (!domainExistsInConfig) {
        logger.warning(`Domain ${domain} configuration files exist but domain is not in config.json.`);
        logger.warning(`Overriding the existing configuration files for ${domain}.`);

        // Clean up existing nginx configs
        await this.nginxService.removeSite(domain);
        return true;
      } else {
        logger.error(`Domain ${domain} already exists.`);
        logger.info(`Please remove the existing configuration first or choose a different domain.`);
        logger.info(`You can use the 'quicky domains' command to manage domains.`);
        return false;
      }
    }

    // Check if domain is already registered in config
    if (domainExistsInConfig) {
      logger.error(`Domain ${domain} is already registered in config.json`);
      logger.info(`Use 'quicky domains' to manage existing domains.`);
      return false;
    }

    return true;
  }

  async addDomain(pid, domain) {
    const project = this.configManager.getProject(pid);
    if (!project) {
      throw new Error(`Project with PID ${pid} not found`);
    }

    try {
      // Validate domain availability first
      const isAvailable = await this.validateDomainAvailability(domain);
      if (!isAvailable) {
        throw new Error("Domain is not available for use");
      }

      // Verify domain ownership and DNS configuration
      logger.info("Verifying domain configuration...");
      await this.domainVerification.checkDomainPointing(domain);

      // Configure Nginx
      await this.nginxService.configureServer(domain, project.port);

      // Verify domain is accessible
      await this.domainVerification.verifyDomainAccess(domain);

      // Obtain SSL certificate
      await this.sslService.obtainCertificate(domain);

      // Save domain configuration
      if (!this.configManager.config.domains) {
        this.configManager.config.domains = [];
      }

      this.configManager.config.domains.push({
        pid,
        domain,
        added: new Date().toISOString(),
        serverIp: await this.domainVerification.getServerIp(),
      });
      this.configManager.saveConfig();

      logger.success(`Domain ${domain} configured successfully`);
      logger.info(`You can now access your project at https://${domain}`);
    } catch (error) {
      logger.error(`Failed to configure domain: ${error.message}`);

      // Cleanup on failure
      await this.cleanupFailedDomain(domain);
      throw error;
    }
  }

  async removeDomain(domain) {
    try {
      // Verify domain exists in config
      const domainConfig = (this.configManager.config.domains || []).find((d) => d.domain === domain);

      if (!domainConfig) {
        throw new Error(`Domain ${domain} not found in configuration`);
      }

      // Remove Nginx configurations
      const nginxConfigPath = `/etc/nginx/sites-available/${domain}`;
      const nginxSymlinkPath = `/etc/nginx/sites-enabled/${domain}`;

      if (fs.existsSync(nginxConfigPath) || fs.existsSync(nginxSymlinkPath)) {
        await this.nginxService.removeSite(domain);
      } else {
        logger.warning(`No Nginx configuration found for ${domain}`);
      }

      // Remove SSL certificate
      await this.sslService.removeCertificate(domain);

      // Update config
      this.configManager.config.domains = this.configManager.config.domains.filter((d) => d.domain !== domain);
      this.configManager.saveConfig();

      logger.success(`Domain ${domain} removed successfully`);
    } catch (error) {
      throw new Error(`Failed to remove domain: ${error.message}`);
    }
  }

  getDomainStatus(domain) {
    const status = {
      inConfig: false,
      hasNginxConfig: false,
      hasSymlink: false,
      hasSSL: false,
    };

    // Check config.json
    status.inConfig = (this.configManager.config.domains || []).some((d) => d.domain === domain);

    // Check Nginx configurations
    status.hasNginxConfig = fs.existsSync(`/etc/nginx/sites-available/${domain}`);
    status.hasSymlink = fs.existsSync(`/etc/nginx/sites-enabled/${domain}`);

    // Check SSL certificate
    status.hasSSL = fs.existsSync(`/etc/letsencrypt/live/${domain}/fullchain.pem`);

    return status;
  }

  async fixInconsistentDomain(domain) {
    const status = this.getDomainStatus(domain);

    if (status.inConfig && (!status.hasNginxConfig || !status.hasSymlink)) {
      logger.warning(`Fixing inconsistent configuration for ${domain}`);
      const domainConfig = this.configManager.config.domains.find((d) => d.domain === domain);

      const project = this.configManager.getProject(domainConfig.pid);
      if (project) {
        await this.nginxService.configureServer(domain, project.port);
      }
    }
  }
}



--- File: src\lib\projectManager.js ---

// src/lib/projectManager.js
import fs from "fs-extra";
import path from "path";
import { v4 as uuidv4 } from "uuid";
import { PATHS } from "../config/constants.js";
import { EnvironmentService } from "../services/environment.js";
import { GitService } from "../services/git.js";
import { PackageManagerService } from "../services/packageManager.js";
import { PM2Service } from "../services/pm2.js";
import { WebhookService } from "../services/webhook.js";
import { ERROR_CODES, QuickyError } from "../utils/errors.js";

export class ProjectManager {
  constructor(configManager) {
    this.configManager = configManager;
    this.gitService = new GitService(configManager.config);
    this.pm2Service = new PM2Service();
    this.webhookService = new WebhookService(configManager.config);
    this.envService = new EnvironmentService();
  }

  async deployProject(options) {
    const { owner, repo, port, branch = "main", packageManager = this.configManager.config.packageManager } = options;

    const pid = uuidv4().slice(0, 5);
    const projectPath = path.join(PATHS.PROJECTS_DIR, repo);
    const tempPath = path.join(PATHS.TEMP_DIR, `${repo}-${pid}`);

    try {
      // Ensure directories exist
      await fs.ensureDir(projectPath);
      await fs.ensureDir(tempPath);

      // Clone to temp directory first
      await this.gitService.cloneRepository(owner, repo, tempPath, branch);

      // Detect package manager from project
      const detectedManager = await PackageManagerService.detectFromProject(tempPath);
      const pmService = new PackageManagerService(detectedManager || packageManager);

      // Validate project structure
      await this.validateProjectStructure(tempPath);

      // Handle environment setup
      await this.envService.promptEnvSetup(tempPath);

      // Install dependencies
      await pmService.installDependencies(tempPath);

      // Build project
      await pmService.buildProject(tempPath);

      // Move to final location
      await fs.move(tempPath, projectPath, { overwrite: true });

      // Setup PM2
      await this.pm2Service.start({
        name: repo,
        cwd: projectPath,
        script: pmService.startCommand,
        args: ["--port", port],
        env: { PORT: port },
      });

      // Setup webhook
      const webhookId = await this.webhookService.setupWebhook(owner, repo);

      // Save configuration
      this.configManager.addProject({
        pid,
        owner,
        repo,
        port,
        branch,
        webhookId,
        packageManager: detectedManager || packageManager,
        last_updated: new Date().toISOString(),
      });

      return pid;
    } catch (error) {
      // Cleanup on failure
      await fs.remove(tempPath);
      await fs.remove(projectPath);
      throw new QuickyError(ERROR_CODES.PROJECT.DEPLOY_FAILED, `Failed to deploy project: ${error.message}`);
    }
  }

  async updateProject(pid, options = {}) {
    const { branch = null, skipBuild = false, force = false } = options;

    const project = this.configManager.getProject(pid);
    if (!project) {
      throw new QuickyError(ERROR_CODES.PROJECT.NOT_FOUND, `Project with PID ${pid} not found`);
    }

    const projectPath = path.join(PATHS.PROJECTS_DIR, project.repo);
    const tempPath = path.join(PATHS.TEMP_DIR, `${project.repo}-update-${Date.now()}`);

    try {
      // Clone to temp directory
      await this.gitService.cloneRepository(project.owner, project.repo, tempPath, branch || project.branch);

      // Backup environment
      await this.envService.backupEnv(projectPath);

      // Copy environment files
      await this.copyEnvironmentFiles(projectPath, tempPath);

      // Setup package manager
      const pmService = new PackageManagerService(project.packageManager);
      await pmService.installDependencies(tempPath);

      if (!skipBuild) {
        await pmService.buildProject(tempPath);
      }

      // Stop PM2 process
      await this.pm2Service.stop(project.repo);

      // Replace project directory
      await fs.remove(projectPath);
      await fs.move(tempPath, projectPath);

      // Restart PM2 process
      await this.pm2Service.start({
        name: project.repo,
        cwd: projectPath,
        script: pmService.startCommand,
        args: ["--port", project.port],
        env: { PORT: project.port },
      });

      // Update configuration
      this.configManager.updateProject(pid, {
        last_updated: new Date().toISOString(),
        ...(branch && { branch }),
      });
    } catch (error) {
      // Attempt recovery
      if (fs.existsSync(projectPath)) {
        await this.pm2Service.restart(project.repo);
      }

      throw new QuickyError(ERROR_CODES.PROJECT.UPDATE_FAILED, `Failed to update project: ${error.message}`);
    } finally {
      await fs.remove(tempPath);
    }
  }

  async deleteProject(pid) {
    const project = this.configManager.getProject(pid);
    if (!project) {
      throw new QuickyError(ERROR_CODES.PROJECT.NOT_FOUND, `Project with PID ${pid} not found`);
    }

    try {
      // Stop and remove PM2 process
      await this.pm2Service.delete(project.repo);

      // Remove webhook
      if (project.webhookId) {
        await this.webhookService.removeWebhook(project.owner, project.repo, project.webhookId);
      }

      // Remove project directory
      const projectPath = path.join(PATHS.PROJECTS_DIR, project.repo);
      await fs.remove(projectPath);

      // Remove from configuration
      this.configManager.removeProject(pid);

      return true;
    } catch (error) {
      throw new QuickyError(ERROR_CODES.PROJECT.DELETE_FAILED, `Failed to delete project: ${error.message}`);
    }
  }

  async validateProjectStructure(projectPath) {
    const requiredFiles = ["package.json", "next.config.js"];
    const missingFiles = requiredFiles.filter((file) => !fs.existsSync(path.join(projectPath, file)));

    if (missingFiles.length > 0) {
      throw new Error(`Missing required files: ${missingFiles.join(", ")}`);
    }

    const packageJson = await fs.readJson(path.join(projectPath, "package.json"));
    if (!packageJson.dependencies?.next) {
      throw new Error("Not a Next.js project: next dependency not found");
    }
  }

  async copyEnvironmentFiles(sourcePath, targetPath) {
    const envFiles = [".env", ".env.local", ".env.production"];
    for (const file of envFiles) {
      const sourcefile = path.join(sourcePath, file);
      if (await fs.pathExists(sourcefile)) {
        await fs.copy(sourcefile, path.join(targetPath, file));
      }
    }
  }
}



--- File: src\services\domainVerification.js ---

// src/services/domainVerification.js
import dns from "dns";
import { promisify } from "util";
import { logger } from "../utils/logger.js";
import { executeCommand } from "../utils/process.js";

const resolveDns = promisify(dns.resolve);

export class DomainVerificationService {
  constructor() {
    this.maxRetries = 10; // 5 minutes total (30 seconds * 10)
  }

  async getServerIp() {
    try {
      // Try multiple methods to get the server's IP
      const methods = [
        "curl -s http://169.254.169.254/latest/meta-data/public-ipv4", // AWS
        "curl -s -4 icanhazip.com",
        "curl -s api.ipify.org",
        "hostname -I | awk '{print $1}'",
      ];

      for (const method of methods) {
        try {
          const ip = (await executeCommand(method, { encoding: "utf8" })).trim();
          if (ip && /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(ip)) {
            return ip;
          }
        } catch {
          continue;
        }
      }
      throw new Error("Could not determine server IP");
    } catch (error) {
      throw new Error(`Failed to get server IP: ${error.message}`);
    }
  }

  async checkDomainPointing(domain, maxRetries = 10, retryDelay = 30000) {
    const serverIp = await this.getServerIp();
    let attempts = 0;

    while (attempts < maxRetries) {
      try {
        const digResult = await executeCommand(`dig +short ${domain}`, { encoding: "utf8" });
        const domainIp = digResult.trim();

        if (domainIp === serverIp) {
          return true;
        }

        logger.warning(`Domain points to ${domainIp || "unknown"}, expected ${serverIp}`);

        attempts++;
        if (attempts < maxRetries) {
          logger.info(`Waiting ${retryDelay / 1000}s before next check ` + `(attempt ${attempts}/${maxRetries})`);
          await new Promise((r) => setTimeout(r, retryDelay));
        }
      } catch (error) {
        logger.error(`DNS check failed: ${error.message}`);
        attempts++;
        if (attempts < maxRetries) {
          await new Promise((r) => setTimeout(r, retryDelay));
        }
      }
    }

    throw new Error(`Domain ${domain} is not pointing to ${serverIp} after ${maxRetries} attempts`);
  }

  async verifyDomainAccess(domain) {
    const spinner = logger.spinner(`Verifying access to ${domain}...`).start();
    try {
      // Try HTTP connection
      const response = await fetch(`http://${domain}`);
      if (response.ok) {
        spinner.success({ text: `✓ Successfully verified access to ${domain}` });
        return true;
      }
    } catch (error) {
      spinner.error({ text: `Could not access ${domain}: ${error.message}` });
      throw new Error(`Domain verification failed: ${error.message}`);
    }
  }
}



--- File: src\services\environment.js ---

// src/services/environment.js
import fs from "fs-extra";
import inquirer from "inquirer";
import path from "path";
import { logger } from "../utils/logger.js";

export class EnvironmentService {
  static async promptEnvSetup(projectPath) {
    const { setupEnv } = await inquirer.prompt([
      {
        type: "confirm",
        name: "setupEnv",
        message: "Would you like to set up environment variables?",
        default: true,
      },
    ]);

    if (setupEnv) {
      const variables = [];
      let addMore = true;

      while (addMore) {
        const {
          key,
          value,
          continue: cont,
        } = await inquirer.prompt([
          {
            type: "input",
            name: "key",
            message: "Enter environment variable name:",
            validate: (input) =>
              /^[A-Z][A-Z0-9_]*$/.test(input) || "Please use uppercase letters, numbers, and underscores",
          },
          {
            type: "input",
            name: "value",
            message: "Enter environment variable value:",
          },
          {
            type: "confirm",
            name: "continue",
            message: "Add another variable?",
            default: false,
          },
        ]);

        variables.push({ key, value });
        addMore = cont;
      }

      await this.createEnvFile(projectPath, Object.fromEntries(variables.map((v) => [v.key, v.value])));
    }
  }

  static async createEnvFile(projectPath, variables = {}) {
    const envPath = path.join(projectPath, ".env");
    const existingEnv = await this.readExistingEnv(envPath);

    const content = Object.entries({ ...existingEnv, ...variables })
      .map(([key, value]) => `${key}=${value}`)
      .join("\n");

    await fs.writeFile(envPath, content);
    logger.success("Environment file created successfully");
  }

  static async readExistingEnv(envPath) {
    try {
      if (await fs.pathExists(envPath)) {
        const content = await fs.readFile(envPath, "utf8");
        return Object.fromEntries(
          content
            .split("\n")
            .filter((line) => line.trim() && !line.startsWith("#"))
            .map((line) => line.split("=").map((part) => part.trim()))
        );
      }
    } catch (error) {
      logger.warning(`Failed to read existing .env file: ${error.message}`);
    }
    return {};
  }

  static async backupEnv(projectPath) {
    const envPath = path.join(projectPath, ".env");
    if (await fs.pathExists(envPath)) {
      const backupPath = path.join(projectPath, `.env.backup-${Date.now()}`);
      await fs.copy(envPath, backupPath);
      logger.info(`Environment file backed up to ${backupPath}`);
    }
  }
}



--- File: src\services\git.js ---

import simpleGit from "simple-git";
import { logger } from "../utils/logger.js";

export class GitService {
  constructor(config) {
    this.config = config;
    this.git = simpleGit();
  }

  async cloneRepository(owner, repo, targetPath) {
    const repoUrl = `https://${this.config.github.access_token}@github.com/${owner}/${repo}.git`;

    try {
      await this.git.clone(repoUrl, targetPath);
      logger.success(`Repository cloned successfully to ${targetPath}`);
    } catch (error) {
      throw new Error(`Failed to clone repository: ${error.message}`);
    }
  }
}



--- File: src\services\nginx.js ---

// src/services/nginx.js - Extended Implementation
import fs from "fs-extra";
import path from "path";
import { v4 as uuidv4 } from "uuid";
import { ERROR_CODES, QuickyError } from "../utils/errors.js";
import { executeCommand } from "../utils/process.js";
import { ValidationService } from "../utils/validation.js";

export class NginxService {
  constructor() {
    this.configDir = "/etc/nginx";
    this.sitesAvailable = path.join(this.configDir, "sites-available");
    this.sitesEnabled = path.join(this.configDir, "sites-enabled");
  }

  async generateConfig(domain, port, options = {}) {
    const { rateLimit = 10, rateBurst = 5, clientMaxBodySize = "50M", proxyTimeout = "60s" } = options;

    const zoneName = `zone_${uuidv4().slice(0, 5)}`;

    return `
    limit_req_zone $binary_remote_addr zone=${zoneName}:10m rate=${rateLimit}r/s;

    server {
        listen 80;
        server_name ${domain};

        # Security headers
        add_header X-Frame-Options "DENY" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';" always;

        # Main proxy configuration
        location / {
            limit_req zone=${zoneName} burst=${rateBurst} nodelay;
            
            proxy_pass http://localhost:${port};
            proxy_http_version 1.1;
            
            # Upgrade WebSocket support
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            
            # Standard headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Optimizations
            proxy_buffering off;
            proxy_buffer_size 128k;
            proxy_buffers 4 256k;
            proxy_busy_buffers_size 256k;
            
            # Timeouts
            proxy_connect_timeout ${proxyTimeout};
            proxy_send_timeout ${proxyTimeout};
            proxy_read_timeout ${proxyTimeout};
            
            # Size limits
            client_max_body_size ${clientMaxBodySize};
        }

        # Static file caching
        location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
            expires 7d;
            add_header Cache-Control "public, no-transform";
        }

        # Logging
        access_log /var/log/nginx/${domain}-access.log combined buffer=512k flush=1m;
        error_log /var/log/nginx/${domain}-error.log warn;
    }`;
  }

  async setupSite(domain, port, options = {}) {
    const validation = ValidationService.validateDomain(domain);
    if (!validation.isValid) {
      throw new QuickyError(ERROR_CODES.DOMAIN.INVALID_FORMAT, `Invalid domain: ${validation.message}`);
    }

    try {
      // Generate and write config
      const config = await this.generateConfig(domain, port, options);
      const configPath = path.join(this.sitesAvailable, domain);
      await fs.writeFile(configPath, config);

      // Create symlink if it doesn't exist
      const symlinkPath = path.join(this.sitesEnabled, domain);
      if (!fs.existsSync(symlinkPath)) {
        await fs.symlink(configPath, symlinkPath);
      }

      // Test and reload
      await this.testConfig();
      await this.reload();

      return true;
    } catch (error) {
      throw new QuickyError(ERROR_CODES.DOMAIN.SETUP_FAILED, `Failed to setup Nginx for ${domain}: ${error.message}`);
    }
  }

  async removeSite(domain) {
    try {
      const configPath = path.join(this.sitesAvailable, domain);
      const symlinkPath = path.join(this.sitesEnabled, domain);

      if (fs.existsSync(symlinkPath)) {
        await fs.unlink(symlinkPath);
      }

      if (fs.existsSync(configPath)) {
        await fs.unlink(configPath);
      }

      // Remove logs
      const logPaths = [`/var/log/nginx/${domain}-access.log`, `/var/log/nginx/${domain}-error.log`];

      for (const logPath of logPaths) {
        if (fs.existsSync(logPath)) {
          await fs.unlink(logPath);
        }
      }

      await this.reload();
      return true;
    } catch (error) {
      throw new QuickyError(
        ERROR_CODES.DOMAIN.SETUP_FAILED,
        `Failed to remove Nginx config for ${domain}: ${error.message}`
      );
    }
  }

  async testConfig() {
    try {
      await executeCommand("sudo nginx -t");
      return true;
    } catch (error) {
      throw new Error(`Nginx configuration test failed: ${error.message}`);
    }
  }

  async reload() {
    try {
      await executeCommand("sudo systemctl reload nginx");
      return true;
    } catch (error) {
      throw new Error(`Failed to reload Nginx: ${error.message}`);
    }
  }
  async getStatus(domain) {
    const configPath = path.join(this.sitesAvailable, domain);
    const symlinkPath = path.join(this.sitesEnabled, domain);

    return {
      hasConfig: fs.existsSync(configPath),
      isEnabled: fs.existsSync(symlinkPath),
      configPath,
      symlinkPath,
      logs: {
        access: `/var/log/nginx/${domain}-access.log`,
        error: `/var/log/nginx/${domain}-error.log`,
      },
    };
  }
}



--- File: src\services\packageManager.js ---

// src/services/packageManager.js
import { logger } from "../utils/logger.js";
import { checkDependency, executeCommand } from "../utils/process.js";

export class PackageManagerService {
  constructor(type = "npm") {
    this.type = type;
  }

  get installCommand() {
    return this.type === "bun" ? "bun install" : "npm install";
  }

  get buildCommand() {
    return this.type === "bun" ? "bun run build" : "npm run build";
  }

  get startCommand() {
    return this.type === "bun" ? "bun run start" : "npm run start";
  }

  async ensureInstalled() {
    if (this.type === "bun" && !checkDependency("bun")) {
      logger.info("Installing Bun...");
      try {
        // Ensure unzip is installed (required for Bun installation)
        if (!checkDependency("unzip")) {
          logger.info("Installing unzip (required for Bun)...");
          await executeCommand("sudo apt-get update && sudo apt-get install -y unzip");
        }

        // Install Bun
        await executeCommand("curl -fsSL https://bun.sh/install | bash");
        // Source the updated profile
        await executeCommand("source ~/.bashrc || source ~/.zshrc || source ~/.bash_profile");

        logger.success("Bun installed successfully");
        return true;
      } catch (error) {
        logger.error(`Failed to install Bun: ${error.message}`);
        throw new Error("Bun installation failed");
      }
    }
    return true;
  }

  async installDependencies(cwd) {
    await this.ensureInstalled();
    logger.info(`Installing dependencies using ${this.type}...`);
    await executeCommand(`${this.installCommand}`, { cwd });
  }

  async buildProject(cwd) {
    logger.info(`Building project using ${this.type}...`);
    await executeCommand(`${this.buildCommand}`, { cwd });
  }

  async startProject(cwd, options = {}) {
    const { port } = options;
    const startCmd = port ? `${this.startCommand} -- --port ${port}` : this.startCommand;
    await executeCommand(startCmd, { cwd });
  }

  // Helper method to detect package manager from project
  static detectFromProject(projectPath) {
    if (checkDependency("bun") && fs.existsSync(`${projectPath}/bun.lockb`)) {
      return "bun";
    }
    return "npm";
  }
}



--- File: src\services\pm2.js ---

import { logger } from "../utils/logger.js";
import { executeCommand } from "../utils/process.js";

export class PM2Service {
  async start(options) {
    const { name, cwd, script = "npm", scriptArgs = ["start"] } = options;
    const command = `pm2 start ${script} --name "${name}" -- ${scriptArgs.join(" ")}`;

    try {
      await executeCommand(command, { cwd });
      logger.success(`Started PM2 process: ${name}`);
    } catch (error) {
      throw new Error(`Failed to start PM2 process: ${error.message}`);
    }
  }

  async stop(name) {
    try {
      await executeCommand(`pm2 stop ${name}`);
      logger.success(`Stopped PM2 process: ${name}`);
    } catch (error) {
      throw new Error(`Failed to stop PM2 process: ${error.message}`);
    }
  }

  async delete(name) {
    try {
      await executeCommand(`pm2 delete ${name}`);
      logger.success(`Deleted PM2 process: ${name}`);
    } catch (error) {
      throw new Error(`Failed to delete PM2 process: ${error.message}`);
    }
  }

  async restart(name) {
    try {
      await executeCommand(`pm2 restart ${name}`);
      logger.success(`Restarted PM2 process: ${name}`);
    } catch (error) {
      throw new Error(`Failed to restart PM2 process: ${error.message}`);
    }
  }

  async describe(name) {
    try {
      const result = await executeCommand(`pm2 describe ${name}`, {
        stdio: "pipe",
        encoding: "utf8",
      });
      return result;
    } catch (error) {
      return null;
    }
  }

  async logs(name, options = { lines: 100, error: false }) {
    const errorFlag = options.error ? "--err" : "";
    try {
      await executeCommand(`pm2 logs ${name} ${errorFlag} --lines ${options.lines}`, { stdio: "inherit" });
    } catch (error) {
      throw new Error(`Failed to get logs: ${error.message}`);
    }
  }
}



--- File: src\services\ssl.js ---

// src/services/ssl.js - Enhanced Implementation
import fs from "fs-extra";
import { ERROR_CODES, QuickyError } from "../utils/errors.js";
import { logger } from "../utils/logger.js";
import { executeCommand } from "../utils/process.js";
import { ValidationService } from "../utils/validation.js";

export class SSLService {
  constructor(email) {
    this.email = email;
    this.certbotPath = "/etc/letsencrypt/live";
  }

  async ensureEmail() {
    if (!this.email) {
      const { email } = await inquirer.prompt([
        {
          type: "input",
          name: "email",
          message: "Enter your email for SSL certificate notifications:",
          validate: (input) => ValidationService.validateEmail(input).isValid,
        },
      ]);
      this.email = email;
    }
    return this.email;
  }

  async obtainCertificate(domain, options = {}) {
    const { forceRenewal = false, staging = false, preferredChallenge = "http" } = options;

    try {
      await this.ensureEmail();

      const cmd = [
        "sudo certbot --nginx",
        `-d ${domain}`,
        "--non-interactive",
        "--agree-tos",
        `--email ${this.email}`,
        forceRenewal ? "--force-renewal" : "",
        staging ? "--staging" : "",
        `--preferred-challenges ${preferredChallenge}`,
      ]
        .filter(Boolean)
        .join(" ");

      await executeCommand(cmd);

      // Verify certificate was obtained
      await this.verifyCertificate(domain);

      logger.success(`SSL certificate obtained for ${domain}`);
      return true;
    } catch (error) {
      throw new QuickyError(ERROR_CODES.DOMAIN.SSL_FAILED, `Failed to obtain SSL certificate: ${error.message}`, [
        "Ensure domain DNS is properly configured",
        "Check if Certbot can access the domain over HTTP",
        "Verify Nginx configuration is correct",
      ]);
    }
  }

  async renewCertificates() {
    try {
      await executeCommand("sudo certbot renew");
      logger.success("SSL certificates renewed successfully");
      return true;
    } catch (error) {
      throw new QuickyError(ERROR_CODES.DOMAIN.SSL_FAILED, `Certificate renewal failed: ${error.message}`);
    }
  }

  async removeCertificate(domain) {
    try {
      await executeCommand(`sudo certbot delete --cert-name ${domain} --non-interactive`);
      logger.success(`SSL certificate removed for ${domain}`);
      return true;
    } catch (error) {
      throw new QuickyError(ERROR_CODES.DOMAIN.SSL_FAILED, `Failed to remove SSL certificate: ${error.message}`);
    }
  }

  async verifyCertificate(domain) {
    const certPath = path.join(this.certbotPath, domain);
    if (!fs.existsSync(certPath)) {
      throw new Error("Certificate files not found");
    }

    try {
      // Verify certificate validity
      await executeCommand(`sudo openssl x509 -noout -dates -in ${path.join(certPath, "cert.pem")}`);
      return true;
    } catch (error) {
      throw new Error(`Certificate verification failed: ${error.message}`);
    }
  }

  async getCertificateInfo(domain) {
    const certPath = path.join(this.certbotPath, domain, "cert.pem");
    if (!fs.existsSync(certPath)) {
      return null;
    }

    try {
      const info = await executeCommand(`sudo openssl x509 -noout -text -in ${certPath}`, { encoding: "utf8" });

      const dates = await executeCommand(`sudo openssl x509 -noout -dates -in ${certPath}`, { encoding: "utf8" });

      // Parse certificate information
      const validFrom = dates.match(/notBefore=(.+)/)?.[1];
      const validTo = dates.match(/notAfter=(.+)/)?.[1];

      return {
        valid: {
          from: new Date(validFrom),
          to: new Date(validTo),
        },
        info: info,
        path: certPath,
      };
    } catch (error) {
      throw new Error(`Failed to get certificate info: ${error.message}`);
    }
  }
}



--- File: src\services\system.js ---

// src/services/system.js
import { logger } from "../utils/logger.js";
import { executeCommand } from "../utils/process.js";

export class SystemService {
  static async ensureDependencies() {
    const dependencies = {
      nginx: "sudo apt install nginx -y",
      certbot: "sudo apt install certbot python3-certbot-nginx -y",
      unzip: "sudo apt install unzip -y",
      pm2: "npm install -g pm2",
    };

    for (const [dep, installCmd] of Object.entries(dependencies)) {
      try {
        await executeCommand(`which ${dep}`);
        logger.info(`${dep} is already installed`);
      } catch {
        logger.info(`Installing ${dep}...`);
        await executeCommand(installCmd);
      }
    }
  }

  static async checkSystemResources() {
    try {
      // Check CPU
      const cpuInfo = await executeCommand("lscpu", { encoding: "utf8" });
      const cpuCores = (cpuInfo.match(/^CPU\(s\):\s+(\d+)/m) || [])[1];

      // Check Memory
      const memInfo = await executeCommand("free -m", { encoding: "utf8" });
      const totalMem = (memInfo.match(/^Mem:\s+(\d+)/m) || [])[1];

      // Check Disk Space
      const diskInfo = await executeCommand("df -h /", { encoding: "utf8" });
      const availableSpace = (diskInfo.match(/\d+(?=%)/) || [])[0];

      if (cpuCores < 1 || totalMem < 1024 || availableSpace < 20) {
        throw new Error("Insufficient system resources");
      }

      return { cpuCores, totalMem, availableSpace };
    } catch (error) {
      throw new Error(`System resource check failed: ${error.message}`);
    }
  }

  static async optimizeSystem() {
    try {
      // Adjust system limits
      await executeCommand("sudo sysctl -w fs.file-max=65535");
      await executeCommand("sudo sysctl -w net.core.somaxconn=65535");

      // Update limits.conf if needed
      const limitsConfig = `
        * soft nofile 65535
        * hard nofile 65535
      `;
      await fs.writeFile("/etc/security/limits.conf", limitsConfig, { flag: "a" });

      logger.success("System optimized for better performance");
    } catch (error) {
      logger.warning(`Failed to optimize system: ${error.message}`);
    }
  }
}



--- File: src\services\webhook.js ---

// src/services/webhook.js - Enhanced Implementation
import crypto from "crypto";
import express from "express";
import { PATHS } from "../config/constants.js";
import { ConfigManager } from "../lib/configManager.js";
import { ProjectManager } from "../lib/projectManager.js";
import { logger } from "../utils/logger.js";
import { PM2Service } from "./pm2.js";

export class WebhookServer {
  constructor(config) {
    this.app = express();
    this.config = config;
    this.pm2Service = new PM2Service();
    this.configManager = new ConfigManager();
    this.projectManager = new ProjectManager(this.configManager);
  }

  async setup() {
    this.app.use(express.json());
    this.app.use(this.validateWebhook.bind(this));
    this.setupRoutes();
    await this.ensureDirectory();
  }

  validateWebhook(req, res, next) {
    const signature = req.headers["x-hub-signature-256"];
    if (!signature) {
      return res.status(401).json({ error: "No signature provided" });
    }

    const hmac = crypto.createHmac("sha256", this.config.webhook.secret);
    const calculatedSignature = `sha256=${hmac.update(JSON.stringify(req.body)).digest("hex")}`;

    if (!crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(calculatedSignature))) {
      return res.status(401).json({ error: "Invalid signature" });
    }

    next();
  }

  setupRoutes() {
    this.app.post("/webhook", async (req, res) => {
      try {
        const { repository, ref } = req.body;

        // Only process pushes to the main branch
        if (!ref.endsWith("main") && !ref.endsWith("master")) {
          return res.json({ status: "ignored", reason: "Not main branch" });
        }

        const project = this.configManager.config.projects.find((p) => `${p.owner}/${p.repo}` === repository.full_name);

        if (!project) {
          return res.status(404).json({ error: "Project not found" });
        }

        logger.info(`Processing webhook for ${repository.full_name}`);
        await this.projectManager.updateProject(project.pid);

        res.json({ status: "success", project: project.pid });
      } catch (error) {
        logger.error(`Webhook processing failed: ${error.message}`);
        res.status(500).json({ error: error.message });
      }
    });

    // Health check endpoint
    this.app.get("/health", (req, res) => {
      res.json({ status: "healthy", timestamp: new Date().toISOString() });
    });
  }

  async ensureDirectory() {
    await fs.ensureDir(PATHS.WEBHOOK_DIR);

    // Create or update env file
    const envPath = path.join(PATHS.WEBHOOK_DIR, ".env");
    const envContent = [
      `WEBHOOK_PORT=${this.config.webhook.port}`,
      `WEBHOOK_SECRET=${this.config.webhook.secret}`,
      `NODE_ENV=production`,
    ].join("\n");

    await fs.writeFile(envPath, envContent);
  }

  async start() {
    try {
      await this.setup();
      const server = this.app.listen(this.config.webhook.port, () => {
        logger.success(`Webhook server listening on port ${this.config.webhook.port}`);
      });

      // Graceful shutdown
      process.on("SIGTERM", () => {
        server.close(() => {
          logger.info("Webhook server shutting down");
          process.exit(0);
        });
      });

      return server;
    } catch (error) {
      throw new QuickyError(ERROR_CODES.GITHUB.WEBHOOK_FAILED, `Failed to start webhook server: ${error.message}`);
    }
  }
}



--- File: src\services\webhookServer.js ---

import crypto from "crypto";
import express from "express";
import { ConfigManager } from "../lib/configManager.js";
import { ProjectManager } from "../lib/projectManager.js";

export class WebhookServer {
  constructor(config) {
    this.app = express();
    this.config = config;
    this.configManager = new ConfigManager();
    this.projectManager = new ProjectManager(this.configManager);
    this.setup();
  }

  setup() {
    this.app.use(express.json());
    this.app.post("/webhook", this.handleWebhook.bind(this));
  }

  verifySignature(payload, signature) {
    const hmac = crypto.createHmac("sha256", this.config.webhook.secret);
    const calculatedSignature = `sha256=${hmac.update(JSON.stringify(payload)).digest("hex")}`;
    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(calculatedSignature));
  }

  async handleWebhook(req, res) {
    const signature = req.headers["x-hub-signature-256"];
    if (!signature || !this.verifySignature(req.body, signature)) {
      return res.status(401).send("Invalid signature");
    }

    const project = this.configManager.config.projects.find(
      (p) => `${p.owner}/${p.repo}` === req.body.repository.full_name
    );

    if (!project) {
      return res.status(404).send("Project not found");
    }

    try {
      await this.projectManager.updateProject(project.pid);
      res.status(200).send("Update successful");
    } catch (error) {
      res.status(500).send(`Update failed: ${error.message}`);
    }
  }

  start(port) {
    return this.app.listen(port, () => {
      console.log(`Webhook server listening on port ${port}`);
    });
  }
}



--- File: src\utils\crypto.js ---

// src/utils/crypto.js
import crypto from "crypto";

export class CryptoUtils {
  static generateSecret(length = 32) {
    return crypto.randomBytes(length).toString("hex");
  }

  static async hashPassword(password) {
    return new Promise((resolve, reject) => {
      crypto.scrypt(password, crypto.randomBytes(16), 64, (err, derivedKey) => {
        if (err) reject(err);
        resolve(derivedKey.toString("hex"));
      });
    });
  }

  static verifySignature(payload, signature, secret) {
    const hmac = crypto.createHmac("sha256", secret);
    const calculatedSignature = `sha256=${hmac.update(JSON.stringify(payload)).digest("hex")}`;
    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(calculatedSignature));
  }
}



--- File: src\utils\errors.js ---

// src/utils/errors.js
export class QuickyError extends Error {
  constructor(code, message, suggestions = []) {
    super(message);
    this.name = "QuickyError";
    this.code = code;
    this.suggestions = suggestions;
  }

  static format(error) {
    if (error instanceof QuickyError) {
      return {
        code: error.code,
        message: error.message,
        suggestions: error.suggestions,
      };
    }

    return {
      code: "UNKNOWN_ERROR",
      message: error.message,
      suggestions: ["Try running the command with --debug flag for more information"],
    };
  }
}

export const ERROR_CODES = {
  SYSTEM: {
    INSUFFICIENT_RESOURCES: "SYS_001",
    DEPENDENCY_INSTALL_FAILED: "SYS_002",
    PERMISSION_DENIED: "SYS_003",
  },
  CONFIG: {
    INVALID_FORMAT: "CFG_001",
    MISSING_REQUIRED: "CFG_002",
    WRITE_FAILED: "CFG_003",
  },
  DOMAIN: {
    INVALID_FORMAT: "DOM_001",
    SETUP_FAILED: "DOM_002",
    SSL_FAILED: "DOM_003",
  },
  GITHUB: {
    AUTH_FAILED: "GIT_001",
    REPO_NOT_FOUND: "GIT_002",
    WEBHOOK_FAILED: "GIT_003",
  },
  PROJECT: {
    DEPLOY_FAILED: "PRJ_001",
    UPDATE_FAILED: "PRJ_002",
    NOT_FOUND: "PRJ_003",
  },
};



--- File: src\utils\fileSystem.js ---

import fs from "fs-extra";
import { PATHS } from "../config/constants.js";

export const ensureDirectories = () => {
  if (!fs.existsSync(PATHS.PROJECTS_DIR)) {
    fs.mkdirSync(PATHS.PROJECTS_DIR, { recursive: true });
  }

  if (!fs.existsSync(PATHS.CONFIG_PATH)) {
    fs.writeFileSync(PATHS.CONFIG_PATH, JSON.stringify({ projects: [] }, null, 2));
  }
};

export const removeDirectory = async (path) => {
  try {
    await fs.remove(path);
    return true;
  } catch (error) {
    throw new Error(`Failed to remove directory: ${error.message}`);
  }
};



--- File: src\utils\logger.js ---

// src/utils/logger.js
import chalk from "chalk";
import { createSpinner } from "nanospinner";
import path from "path";
import winston from "winston";

export class Logger {
  constructor() {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || "info",
      format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
      transports: [
        new winston.transports.File({
          filename: path.join(PATHS.DEFAULT_FOLDER, "error.log"),
          level: "error",
        }),
        new winston.transports.File({
          filename: path.join(PATHS.DEFAULT_FOLDER, "combined.log"),
        }),
      ],
    });

    if (process.env.NODE_ENV !== "production") {
      this.logger.add(
        new winston.transports.Console({
          format: winston.format.combine(winston.format.colorize(), winston.format.simple()),
        })
      );
    }
  }

  info(message) {
    console.log(chalk.blue("ℹ"), message);
    this.logger.info(message);
  }

  success(message) {
    console.log(chalk.green("✔"), message);
    this.logger.info(message);
  }

  warning(message) {
    console.log(chalk.yellow("⚠"), message);
    this.logger.warn(message);
  }

  error(message, error = null) {
    console.error(chalk.red("✖"), message);
    this.logger.error(message, error);
  }

  debug(message) {
    this.logger.debug(message);
  }

  spinner(message) {
    return createSpinner(message);
  }
}

export const logger = new Logger();



--- File: src\utils\network.js ---

// src/utils/network.js
import dns from "dns";
import net from "net";
import { promisify } from "util";

const dnsResolve = promisify(dns.resolve);

export class NetworkUtils {
  static async checkPort(port) {
    return new Promise((resolve) => {
      const server = net.createServer();

      server.once("error", (err) => {
        resolve({
          available: false,
          error: err.code,
        });
      });

      server.once("listening", () => {
        server.close();
        resolve({ available: true });
      });

      server.listen(port);
    });
  }

  static async findAvailablePort(startPort = 3000, endPort = 9000) {
    for (let port = startPort; port <= endPort; port++) {
      const { available } = await this.checkPort(port);
      if (available) return port;
    }
    throw new Error("No available ports found in range");
  }

  static async verifyDomain(domain) {
    try {
      const records = await dnsResolve(domain);
      return {
        valid: true,
        records,
        type: "A",
      };
    } catch (error) {
      return {
        valid: false,
        error: error.code,
      };
    }
  }

  static async getPublicIp() {
    try {
      const response = await fetch("https://api.ipify.org?format=json");
      const data = await response.json();
      return data.ip;
    } catch (error) {
      throw new Error(`Failed to get public IP: ${error.message}`);
    }
  }
}



--- File: src\utils\process.js ---

import { execSync } from "child_process";

export const executeCommand = (command, options = {}) => {
  try {
    return execSync(command, { stdio: "inherit", ...options });
  } catch (error) {
    throw new Error(`Command failed: ${error.message}`);
  }
};

export const checkDependency = (dependency) => {
  try {
    execSync(`which ${dependency}`, { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
};



--- File: src\utils\system.js ---

// src/utils/system.js
import os from "os";
import { executeCommand } from "./process.js";

export class SystemUtils {
  static async getSystemInfo() {
    try {
      const cpus = os.cpus();
      const totalMemory = os.totalmem();
      const freeMemory = os.freemem();
      const loadAvg = os.loadavg();

      return {
        cpu: {
          cores: cpus.length,
          model: cpus[0].model,
          speed: cpus[0].speed,
          loadAvg: loadAvg[0],
        },
        memory: {
          total: totalMemory,
          free: freeMemory,
          used: totalMemory - freeMemory,
          percentUsed: (((totalMemory - freeMemory) / totalMemory) * 100).toFixed(2),
        },
        platform: os.platform(),
        arch: os.arch(),
        uptime: os.uptime(),
      };
    } catch (error) {
      throw new Error(`Failed to get system info: ${error.message}`);
    }
  }

  static async checkDiskSpace(path = "/") {
    try {
      const df = await executeCommand(`df -k ${path}`, { encoding: "utf8" });
      const lines = df.trim().split("\n");
      const [, info] = lines;
      const [, total, used, available] = info.split(/\s+/);

      return {
        total: parseInt(total) * 1024,
        used: parseInt(used) * 1024,
        available: parseInt(available) * 1024,
        percentUsed: ((parseInt(used) / parseInt(total)) * 100).toFixed(2),
      };
    } catch (error) {
      throw new Error(`Failed to check disk space: ${error.message}`);
    }
  }

  static async checkPortAvailability(port) {
    try {
      const netstat = await executeCommand("netstat -tuln");
      return !netstat.includes(`:${port}`);
    } catch (error) {
      return true; // Assume port is available if netstat fails
    }
  }
}



--- File: src\utils\systemCheck.js ---

import { logger } from "./logger.js";
import { executeCommand } from "./process.js";

export const checkSwap = async () => {
  try {
    const swapInfo = executeCommand("swapon --show", { encoding: "utf-8" });
    return swapInfo.includes("/swapfile");
  } catch (error) {
    return false;
  }
};

export const createSwap = async (size = "1G") => {
  try {
    logger.info(`Creating ${size} swap space...`);

    // Check if swap already exists
    if (await checkSwap()) {
      logger.info("Swap space already exists");
      return true;
    }

    // Check available disk space
    const diskSpace = await executeCommand("df -h / --output=avail", {
      encoding: "utf8",
    });
    if (parseInt(diskSpace) < parseInt(size)) {
      throw new Error("Insufficient disk space for swap creation");
    }

    await executeCommand(`sudo fallocate -l ${size} /swapfile`);
    await executeCommand("sudo chmod 600 /swapfile");
    await executeCommand("sudo mkswap /swapfile");
    await executeCommand("sudo swapon /swapfile");
    await executeCommand("echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab");

    logger.success("Swap space created and enabled successfully");
    return true;
  } catch (error) {
    logger.error(`Failed to create swap space: ${error.message}`);
    if (error.message.includes("Permission denied")) {
      logger.error("Please ensure you have sudo privileges");
    }
    return false;
  }
};



--- File: src\utils\updateChecker.js ---

import inquirer from "inquirer";
import latestVersion from "latest-version";
import semver from "semver";
import { packageJson } from "../config/packageJson.js";
import { logger } from "./logger.js";
import { executeCommand } from "./process.js";

export const checkForUpdates = async () => {
  try {
    const latest = await latestVersion("quicky");

    if (semver.gt(latest, packageJson.version)) {
      logger.info(`\n🚀 A new version of Quicky (v${latest}) is available!`);

      const { shouldUpgrade } = await inquirer.prompt([
        {
          type: "confirm",
          name: "shouldUpgrade",
          message: "Would you like to update Quicky to the latest version?",
          default: true,
        },
      ]);

      if (shouldUpgrade) {
        await executeCommand("sudo npm install -g quicky");
        logger.success("Quicky has been upgraded to the latest version");
      } else {
        logger.info("You can upgrade later by running 'quicky upgrade'");
      }
    }
  } catch (error) {
    // Silently handle update check errors
    console.error("Error checking for updates:", error);
  }
};



--- File: src\utils\validation.js ---

// src/utils/validation.js
export class ValidationService {
  static validateProjectName(name) {
    const regex = /^[a-zA-Z0-9-_]+$/;
    return {
      isValid: regex.test(name),
      message: regex.test(name) ? null : "Project name can only contain letters, numbers, hyphens, and underscores",
    };
  }

  static validatePort(port) {
    const portNum = parseInt(port);
    return {
      isValid: !isNaN(portNum) && portNum > 0 && portNum < 65536,
      message: "Port must be between 1 and 65535",
    };
  }

  static validateDomain(domain) {
    const regex = /^(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    return {
      isValid: regex.test(domain),
      message: regex.test(domain) ? null : "Invalid domain format",
    };
  }

  static validateGithubToken(token) {
    // GitHub token format validation
    const regex = /^(ghp_|github_pat_)[a-zA-Z0-9_]+$/;
    return {
      isValid: regex.test(token),
      message: "Invalid GitHub token format",
    };
  }

  static validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return {
      isValid: regex.test(email),
      message: "Invalid email format",
    };
  }

  static validatePackageJson(packageJson) {
    const requiredFields = ["name", "version", "scripts"];
    const missingFields = requiredFields.filter((field) => !packageJson[field]);

    if (missingFields.length > 0) {
      return {
        isValid: false,
        message: `Missing required fields: ${missingFields.join(", ")}`,
      };
    }

    if (!packageJson.scripts.start || !packageJson.scripts.build) {
      return {
        isValid: false,
        message: "Missing required scripts: start and build",
      };
    }

    return { isValid: true, message: null };
  }
}



--- File: src\__tests__\integration\deployment.test.js ---

// src/__tests__/integration/deployment.test.js
import { ConfigManager } from "../../lib/configManager";
import { ProjectManager } from "../../lib/projectManager";
import { NetworkUtils } from "../../utils/network";
import { SystemUtils } from "../../utils/system";

describe("Project Deployment Flow", () => {
  let projectManager;
  let configManager;

  beforeEach(async () => {
    configManager = new ConfigManager();
    projectManager = new ProjectManager(configManager);

    // Ensure system requirements
    const sysInfo = await SystemUtils.getSystemInfo();
    expect(sysInfo.memory.free).toBeGreaterThan(512 * 1024 * 1024); // 512MB
  });

  it("should complete full deployment flow", async () => {
    // Find available port
    const port = await NetworkUtils.findAvailablePort();

    // Deploy project
    const pid = await projectManager.deployProject({
      owner: "test-owner",
      repo: "test-repo",
      port,
    });

    // Verify project status
    const project = configManager.getProject(pid);
    expect(project).toBeDefined();

    // Check PM2 process
    const pm2Status = await projectManager.pm2Service.getStatus(project.repo);
    expect(pm2Status).toBe("online");

    // Verify port is in use
    const portCheck = await NetworkUtils.checkPort(port);
    expect(portCheck.available).toBe(false);

    // Clean up
    await projectManager.deleteProject(pid);
  });
});



--- File: src\__tests__\integration\webhook.test.js ---

// src/__tests__/integration/webhook.test.js
import fetch from "node-fetch";
import { ConfigManager } from "../../lib/configManager";
import { WebhookServer } from "../../services/webhookServer";
import { CryptoUtils } from "../../utils/crypto";

describe("Webhook Server", () => {
  let webhookServer;
  let server;
  let port;

  beforeAll(async () => {
    const configManager = new ConfigManager();
    port = await NetworkUtils.findAvailablePort(9000);

    webhookServer = new WebhookServer({
      ...configManager.config,
      webhook: {
        port,
        secret: CryptoUtils.generateSecret(),
      },
    });

    server = await webhookServer.start();
  });

  afterAll((done) => {
    server.close(done);
  });

  it("should handle valid webhook requests", async () => {
    const payload = {
      repository: {
        full_name: "test-owner/test-repo",
      },
      ref: "refs/heads/main",
    };

    const signature = CryptoUtils.generateSignature(payload, webhookServer.config.webhook.secret);

    const response = await fetch(`http://localhost:${port}/webhook`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Hub-Signature-256": signature,
      },
      body: JSON.stringify(payload),
    });

    expect(response.status).toBe(200);
    const data = await response.json();
    expect(data.status).toBe("success");
  });
});



--- File: src\__tests__\unit\configManager.test.js ---

// src/__tests__/unit/configManager.test.js
import { ConfigManager } from "../../lib/configManager";
import { QuickyError } from "../../utils/errors";

describe("ConfigManager", () => {
  let configManager;

  beforeEach(() => {
    configManager = new ConfigManager();
  });

  describe("addProject", () => {
    it("should add a project successfully", () => {
      const project = {
        pid: "test1",
        owner: "test-owner",
        repo: "test-repo",
        port: 3000,
      };

      configManager.addProject(project);
      const savedProject = configManager.getProject("test1");
      expect(savedProject).toEqual(project);
    });

    it("should throw error for duplicate project", () => {
      const project = {
        pid: "test1",
        owner: "test-owner",
        repo: "test-repo",
        port: 3000,
      };

      configManager.addProject(project);
      expect(() => configManager.addProject(project)).toThrow(QuickyError);
    });
  });
});



--- File: src\__tests__\unit\projectManager.test.js ---

// src/__tests__/unit/projectManager.test.js
import { ConfigManager } from "../../lib/configManager";
import { ProjectManager } from "../../lib/projectManager";
import { QuickyError } from "../../utils/errors";

describe("ProjectManager", () => {
  let projectManager;
  let configManager;

  beforeEach(() => {
    configManager = new ConfigManager();
    projectManager = new ProjectManager(configManager);
  });

  describe("deployProject", () => {
    it("should successfully deploy a project", async () => {
      const options = {
        owner: "test-owner",
        repo: "test-repo",
        port: 3000,
      };

      const pid = await projectManager.deployProject(options);
      expect(pid).toBeDefined();
      expect(pid).toHaveLength(5);

      const project = configManager.getProject(pid);
      expect(project).toBeDefined();
      expect(project.owner).toBe(options.owner);
      expect(project.repo).toBe(options.repo);
      expect(project.port).toBe(options.port);
    });

    it("should throw error when project validation fails", async () => {
      const options = {
        owner: "test-owner",
        repo: "invalid-repo",
        port: 3000,
      };

      await expect(projectManager.deployProject(options)).rejects.toThrow(QuickyError);
    });
  });
});

